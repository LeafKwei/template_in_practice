# 《特殊成员函数的模板》

成员函数模板也可以用于特殊的成员函数，例如构造函数，并可能产生一些奇妙的特性。考虑下方的代码：

```c++
class Person{
public:
    Person(const std::string &str) : str_(str){ std::cout << "Person(string&)" << std::endl; }
    Person(std::string &&str) : str_(std::move(str)){ std::cout << "Person(string&&)" << std::endl; }

    Person(const Person &other) : str_(other.str_){ std::cout << "Person(Person&)" << std::endl; }
    Person(Person &&other) : str_(std::move(other.str_)){ std::cout << "Person(Person&&)" << std::endl;}

private:
    std::string str_;
};

```

我们分别定义了两组构造函数，其中一组以字符串初始化Person，为了支持移动语义，我们重载了一个移动string对象的构造函数；另一组则是Person的拷贝构造函数和移动构造函数。然后，我们按下面的方式来调用这些构造函数：

```c++
std::string str("Tom");
Person p1(str);           //p1通过拷贝str进行初始化
Person p2("Jerry");       //p2通过窃取从字面量Jerry生成的临时string对象的资源进行初始化

Person p3(p1);            //p3通过拷贝p1进行初始化
Person p4(std::move(p2)); //p4通过窃取p2的资源进行初始化
```

当我们以左值初始化时，调用的是拷贝版本的构造函数，反之，使用右值初始化时，调用的是移动版本。

现在，让我们将使用string初始化的那一组构造函数改造为函数模板，将传递进来的参数完美转发给str_：

```c++
class Person{
public:
    template<typename Arg>
    Person(Arg &&arg) : str_(std::forward<Arg>(arg)){ 
        std::cout << "template Person(Arg)" << std::endl; 
    }

    Person(const Person &other) : str_(other.str_){ std::cout << "Person(Person&)" << std::endl; }
    Person(Person &&other) : str_(std::move(other.str_)){ std::cout << "Person(Person&&)" << std::endl;}

private:
    std::string str_;
};
```

此时，如果我们以下列的方式来初始化Person，一切正常：

```c++
std::string str("Tom");
Person p1(str);
Person p2("Jerry");
Person p3(std::move(p2));
const Person cp1("Smith");
Person p4(cp1)
```

可以看到，无论是使用string、右值形式的Person、const形式的Person，初始化过程都是顺利的，而一旦我们尝试使用左值形式的Person来初始化，那么将会得到一个<u>no matching function</u>的错误：

```c++
Person p1(str);
Person p2(p1);
```

编译器似乎并没有按照我们预想的那样，调用我们的拷贝构造函数`Person(const Person &other)`来对Person进行初始化，相反，编译器认为函数模板`Person(Arg &&arg)`要比我们的拷贝构造函数匹配的更好(再次提醒，使用模板参数声明的**Arg &&arg**并不是一个右值引用，而是一个转发引用/万能引用，只是它的语法恰巧和右值引用类似)。因此，我们传递的Person被转发给了str_，其结果便是string类型没有可接受Person类型的构造函数，最终引发了上述错误。当我们使用右值或const形式的Person时，由于存在比函数模板更特例化的拷贝构造函数`Person(Person &&other)`和`Person(const Person &other)`，所以不会引发上述错误。我们可能会想到再提供一个使用左值的拷贝构造函数`Person(Person &other)`，但这只能解决部分问题，一旦我们使用Person的派生类初始化Person时，相同的问题将会再次出现。彻底解决这个问题需要使用到一个标准库中的工具——`std::enable_if`，我们将在后续介绍。
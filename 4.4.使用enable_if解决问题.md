# 《使用enable_if解决问题》

**【处理Person的拷贝问题】**

回想我们在前面提到过的Person类，在当时，由于函数模板`Person(Arg &&arg)`比我们定义的`Person(const Person &other)`匹配的更好，导致我们使用一个左值形式的Person初始化另一个Peson类时，编译器会选择`Person(Arg &&arg)`而不是我们定义的拷贝构造函数。在学习了`std::enable_if`后，我们现在可以在相同的情况下禁用该模板，为此，我们要使用到标准库中的另一个工具模板：

```c++
std::is_convertible<FROM,TO>
```

它可以判断类型FROM是否可以转换为类型TO，我们将使用它来判断传递给`Person(Arg &&arg)`的类型Arg是否可以转换为std::string类型，如果可以，再启用该模板，否则通过SFINAE禁用该模板。修改后的Person类如下：

```c++
class Person{
public:
    template<typename Arg,
    	typename=std::enable_if_t<std::is_convertible<Arg,std::string>::value>>
    Person(Arg &&arg) : str_(std::forward<Arg>(arg)){ 
        std::cout << "template Person(Arg)" << std::endl; 
    }

    Person(const Person &other) : str_(other.str_){ std::cout << "Person(Person&)" << std::endl; }
    Person(Person &&other) : str_(std::move(other.str_)){ std::cout << "Person(Person&&)" << std::endl;}

private:
    std::string str_;
};
```

其中，`std::is_convertible<Arg,std::string>::value`会在Arg对应的类型可以转换为std::string时表达为true，反之则表达为false，我们也可以使用它的别名模板`std::is_convertible_v<Arg,std::string>>`予以简化。然后，我们再次运行下方的程序：

```c++
Person p1("Tom");
Person p2(p1);
```

由于`"Tom"`的类型`const char [3]`可以转换为std::string，因此p1将会使用函数模板`Person(Arg &&arg)`进行初始化，而如果我们使用p1初始化，由于Person无法转换为std::string，导致`Person(Arg &&arg)`被禁用，从而让p2得以使用拷贝构造函数`Person(const Person &other)`进行初始化。

当然，我们同样可以使用别名模板来简化上述的代码：

```c++
template<typename T>
using EnableIfString = std::enable_if_t<std::is_convertible_v<T,std::string>>;

class Person{
public:
    template<typename Arg,
    	typename=EnableIfString<Arg>>
    Person(Arg &&arg) : str_(std::forward<Arg>(arg)){ 
        std::cout << "template Person(Arg)" << std::endl; 
    }
  	/* 省略其他代码 */  
};
```



**【使用concept简化enable_if】**

即使是使用别名模板，我们也能看出`std::enable_if`的语法相当的冗长。为了达到预期效果，我们还要在模板上添加一个额外的模板参数，然后借助这个模板参数来指定我们想要对模板进行的“约束“，这样的代码难以阅读和理解。自C++20开始，一个被称为**Concepts**的语言特性让我们可以更加清晰地定义和使用这些约束。让我们先尝试使用Concepts来简化我们的Person类：

```c++
template<typename T>
concept StringConvertible = std::is_convertible_v<T,std::string>;

class Person{
public:
    template<typename Arg>
    requires StringConvertible<Arg>
    Person(Arg &&arg) : str_(std::forward<Arg>(arg)){ 
        std::cout << "template Person(Arg)" << std::endl; 
    }
  	/* 省略其他代码 */  
};
```

一个concept的定义以关键字`concept`开始，然后是concept的名称`StringConvertible`，在等号的右侧是一个可以在编译期求值的bool表达式`std::is_convertible_v<T,std::string>`。concept必须按照模板的形式进行定义，即使等号右侧的表达式不使用任何模板参数，我们也必须声明至少一个模板参数：

```c++
template<typename T>
concept AlwaysTrue = true;
```

使用concept需要借助关键字`requires`，只有在requires右侧的表达式为true时，模板才会启用：

```c++
template<typename T>
requires StringConvertible<T>  //要求T可以转换为std::string
void foo(T v){}
```

此外我们还可以直接用concept替代掉模板参数声明中的typename关键字，也能达到约束模板参数的效果：

```c++
template<StringConvertible T>
void foo(T v){}
```



**【添加多个约束】**

我们可以将concept视为一个编译期的bool型模板变量，这意味着我们可以对concept进行布尔运算，当我们想要对模板添加多个约束时，就可以使用`&&`操作符连续判断多个concept：

```c++
template<typename T>
concept StringConvertible = std::is_convertible_v<T,std::string>;

template<typename T>
concept AtLeastSize4 = (sizeof(T) >= 4);

template<typename T>
requires StringConvertible<Arg> && AtLeastSize4  //要求T可以转换为std::string并且类型大小至少为4
void foo(T v){}
```








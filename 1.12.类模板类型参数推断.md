# 《类模板类型参数推断》

## 从构造函数推断模板参数

在C++17之前，我们在实例化一个类模板时必须手动指定每一个类型参数，除非为该参数指定了默认类型。在C++17以后，编译器可以从构造函数的参数中推断类模板的类型参数。但是，一旦决定让编译器从构造函数中推断类型参数，就必须确保所有的类型参数都能从构造函数中推断得到，如果某个类型参数无法从构造函数中推断出来，那么就仍然需要手动指定每个类型参数。关于这一点，函数模板与类模板不同，当函数模板无法从参数中推断出所有类型参数时，我们只需手动指定没有推断出的类型参数的类型即可。

以类模板Pair为例：

```c++
template<typename T, typename U>
struct Pair{
    Pair(T fst) : first(fst){}
	Pair(T fst, U snd) : first(fst), second(snd){}
	
	T first;
	U second;
};

Pair pair(100, 9.8);   //从100推断T为int，从9.8推断U为double
Pair<int,double>(100); //无法推断出U的类型，因此两个类型参数都需要手动指定
```

使用构造函数`Pair(T fst, U snd)`时，编译器可以从两个参数中推断出T和U的类型，因此我们无需手动指定类型。而在使用构造函数`Pair(T fst)`时，由于无法推断出U的类型，因此需要手动指定每个类型参数的类型。

作为对比，我们再来看看函数模板在类似情况下的类型推断：

```c++
template<typename P, typename T, typename U>
void print(T arg1, U arg2){
	P stream;
	stream << arg1 << arg2 << std::endl;
	std::cout << stream.str() << std::endl;
}

print<std::stringstream>(100, 200); //类型参数P无法从函数参数中推断，因此需要手动指定
```

可以看到，类型参数P无法从函数参数中推断出来，但我们无需手动指定所有类型参数的类型，只需要指定类型参数P的类型即可。但这一切都有一个前提，就是确保无法推断的类型参数(本例中的P)始终位于类型参数声明的最左侧，因为当我们手动指定类型时，编译器会将这些类型按顺序依次替换类型参数声明中的每个类型参数，一旦顺序有误，那么替换后的结果也是错误的。例如：

```
template<typename G, typename P, typename T, typename U>
void print(G arg0, T arg1, U arg2){
	P stream;
	stream << arg1 << arg2 << std::endl;
	std::cout << stream.str() << std::endl;
}

print<std::stringstream>('c', 100, 200); //错误，无法推断类型参数P
```

虽然这个例子中我们同样手动指定了类型参数，但由于P的位置在G的右侧，所以类型`std::stringstream`就被编译器用于替换了类型参数G，而P又无法从函数参数中推断，最终导致整个函数模板匹配失败。



## 字符串字面量与类型推断

如果打算在类模板的构造函数参数中使用字符串字面量(原始数组也是同理)，并且该参数还被用于类型参数的推断，就需要特别注意字符串字面量的退化问题。首先我们来看以下使用引用和非引用情况下，类型自动推断的结果：

```c++
auto p = "Hello";
auto &pr = "Hello";

std::cout << typeid(p).name() << std::endl;  //const char*
std::cout << typeid(pr).name() << std::endl; //const char[6]
```

从打印的结果我们可知，非引用变量p的类型被推断为`const char*`，而引用变量pr的类型被推断为了`const char[6]`，由此可得，当在使用非引用的情况下，自动推断的类型将发生退化，数组会退化为数组元素的指针；而在使用引用的情况下，自动推断的类型将保持和被引用的对象相同的类型和属性，不会发生退化。

有了上面的经验，我们再来看如下例子：

```c++
template<typename T>
struct Wrapper{
	Wrapper(T &cont) : content(cont){}
	T content;
};

Wrapper wrap("Hello"); //错误，使用数组作为初始化器
```

在这个例子中，我们将参数`cont`声明为了T类型的引用`T&`，并且在构造Wrapper时使用了字符串字面量`"Hello"`作为构造函数参数，根据我们上面的经验，在使用引用时，编译器会将T的类型推断为`const char [6]`，那么Wrapper将被实例化为如下形式：

```c++
struct Wrapper{
	Wrapper(const char (&cont)[6]) : content(cont){}
	const char content[6];
};
```

所以我们实际上正在用一个数组去初始化另一个数组，这显然是不允许的。此外，在类型不退化的情况下，不同长度的数组拥有不同的类型，例如`char[5]`和`char[6]`虽然拥有相同的元素类型，但它们的长度不同，因此是不同的类型，这就意味着当我们使用字符串字面量初始化Wrapper时，不同长度的字符串字面量会实例化出不同的Wrapper：

```c++
Wrapper wrap("Hello");     //实例化为Wrapper<const char[6]>
Wrapper wrap2("HappyDay"); //实例化为Wrapper<const char[8]>
```

要解决上述问题，我们需要将构造函数参数改为非引用形式，即所谓的**按值传递**：

```c++
template<typename T>
struct Wrapper{
	Wrapper(T cont) : content(cont){}
	T content;
};

Wrapper wrap("Hello"); //实例化为Wrapper<const char*>
```

由于类型退化的缘故，T将被推断为`const char*`，而使用一个指针初始化另一个同类型指针是完全合法的。同时，由于指针不涉及到数组长度，所以使用不同长度的字符串字面量也可以正常工作。



## 推断引导

推断引导(Deduction guides)可以改变编译器实例化类模板时使用的类型——通过给出一条引导声明，让编译器在类模板的构造函数参数类型满足条件的情况下，按照指定的类型实例化类模板。推断引导的使用方式如下所示：

```c++
Wrapper(const char*) -> Wrapper<std::string>;
```

通过这条引导声明，当我们以构造函数`Wrapper(T cont)`初始化Wrapper时，如果T被推断为`const char*`，那么编译器将不再实例化出`Wrapper<const char*>`版本，而是实例化出`Wrapper<std::string>`版本。




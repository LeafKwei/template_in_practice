# 《SFINAE》
## SFINAE





## SFINAE与重载





## 表达式SFINAE与decltype

**【】**

想要找出并使用正确地表达式来“筛选”出用于特定条件下的函数模板并不总是那么容易。例如，对于函数模板len：

```c++
template<typename T>
typename T::size_type len(const T &arg){
	return arg.size();
}
```

如果我们想要让函数模板len在函数参数的类型T中存在类型成员`size_type`但不存在成员函数`size()`时被忽略，那么仅凭上述的声明是无法做到的，因为在声明中没有体现出任何形式的对于T的成员函数`size()`的使用。我们知道，类型替换(substitution)过程仅对函数模板的声明执行推断和匹配，不会涉及到函数体(function body)，因此我们在函数体中的语句`return arg.size()`在替换过程并不能起到帮助编译器判断的作用。因此，对于以下语句：

```c++
std::allocator<int> alloc;
len(alloc);    //错误，函数模板len虽然被选中，没有allocator没有成员函数size可供调用
```

类型`std::allocator`拥有类型成员`size_type`，因此它可以通过替换过程的检查，所以对于allocator，函数模板len被选中了，但在随后实例化的过程中，编译器发现allocator不存在成员函数`size`，随即报错。

**【】**

# 《SFINAE》
## SFINAE

**【候选函数模板与替换】**

在C++中，为了适配多种类型而重载函数相当常见。当编译器发现一个对重载函数的调用时，它必须考虑到每一个可能的候选函数，为此编译器需要先对调用中的各个参数求值，并从候选函数中选出匹配的最好的那个。

如果候选函数中包含函数模板，那么编译器首先还需决定应该对该模板采用的模板参数类型，然后以该类型替换函数模板的参数列表和返回值类型中相应的模板参数，最后，编译器再进行求值，并评估函数模板的匹配程度。然而，在将模板参数替换为具体类型的阶段却可能出现问题，但这个问题并不会导致错误——相反，C++语言标准规定，在替换阶段出现问题的候选函数模板只是简单地被忽略。

这个原则被称为**SFINAE**，完整意思为“Substitution Failure Is Not An Error”(替换失败不是错误)。

需要注意，这里提到的替换过程和按需实例化(on-demand instantiation)的过程是有区别的，因为需要在类型替换后判断函数模板是否匹配，因此即使对于那些实际上不会使用到的候选函数模板，替换也可能照样会发生，相反，按需实例化只有在找到匹配的模板后才会发生。替换只针对直接存在于函数声明中的内容，因此替换过程中只会涉及到函数声明(declaration)，不会涉及到函数体(body)。

考虑下方的例子：

```c++
/* 要求参数是一个原始数组 */
template<typename T, unsigned N>
std::size_t len(const T (&arg)[N]){
	return N;
}

/* 要求参数的类型T具有类型成员size_type */
template<typename T>
typename T::size_type len(const T &arg){
	return arg.size();
}
```

第一个函数模板的参数`T (&arg)[N]`意味着它的参数必须是一个拥有N个T类型元素的数组；第二个函数模板的参数简单地声明为了`T&`，因此它对参数没有做限制，但它的返回类型为`T::size_type`，这要求类型T必须具有一个类型成员`size_type`。

当我们传递一个数组或字符串字面量时，将会选中第一个函数模板：

```c++
int arr[10];
len(arr);     //选中第一个函数模板
len("Hello"); //选中第一个函数模板
```

按照函数声明，当T被替换为`int [10]`或`char [6]`时，第二个函数模板似乎也可以匹配这些调用，但是在替换阶段，该函数模板的返回值类型`T::size_type`会导致替换失败，因为`int [10]`和`char [6]`两者并没有类型成员`size_type`，所以对于这些调用而言，第二个函数模板将被忽略。

如果我们传递的是一个vector，那么第二个函数模板会被选中，因为vector拥有类型成员`size_type`：

```
std::vector<int> vec(10);
len(vec);  //选中第二个函数模板
```

当我们传递一个指针时，由于它既不是数组，也不具有类型成员`size_type`，因此两个函数模板都会由于替换失败而被忽略，此时因为没有其他候选函数，所以编译器将报告错误：没有找到匹配的函数`len()`：

```c++
int *p;
len(p);  //错误，没有匹配的函数
```

作为对比，我们来看一下当参数是一个`std::allocator`时会发生什么：

```c++
std::allocator<int> alloc;
len(alloc); //错误，std::allocator不存在size函数
```

`std::allocator`拥有类型成员`size_type`，但却没有成员函数`size`， 因此可以预料到，`len(alloc)`在编译时同样会发生错误，但导致该错误的原因与`len(p)`并不相同，这两个错误分别发生在不同的阶段。首先是`len(p)`，它是在替换失败后没有候选函数而导致的错误；然后是`len(alloc)`，由于`std::allocator`拥有类型成员`size_type`，所以在替换阶段，编译器发现第二个函数模板可以匹配`len(alloc)`，因此第二个函数模板没有被忽略，而是进入了下一阶段，然而，`std::allocator`没有成员函数`size`，所以在后续的编译过程中，编译器发现了这个问题，从而报告错误。

**【指针和allocator的错误差别】**

为了更清晰地看出指针和`std::allocator`的错误之间的差别，我们添加一个用作回落方案[1]的普通函数：

```c++
std::size_t len(...){
	return 0;
}
```

这个函数的特点是在参数列表的部分使用了省略号`...`，是一个典型的C风格的可变参数函数，表示该函数可以接受任意类型，任意数量的参数，但也正因没有指定明确的参数类型、数量，在编译器尝试匹配`len(p)`、`len(alloc)`等调用时，往往会优先尝试那些定义更加精确的候选函数(例如我们的两个函数模板)，只有在尝试了其他所有可能的候选函数后，才会选择该函数。我们添加这个函数的目的是将它作为调用`len()`时的一个回落方案，当我们的函数模板都因为替换失败而被忽略时，由于没有其他可选的候选函数，编译器只能选择该`len(...)`作为回落方案。

此时我们再次对指针和`std::allocator`调用len函数：

```c++
int *p;
std::allocator<int> alloc;

len(p);        //OK，返回0
len(alloc);    //错误，std::allocator没有size函数
```

对比两个调用结果我们可以发现，在增加备用的len函数后，当两个函数模板因为替换失败而被忽略时，编译器为`len(p)`选择了备用的len函数，而没有像之前那样直接报告找不到匹配的len函数的错误；与之相对的，由于`std::allocator`对第二个函数模板而言可以替换成功，因此编译器为`len(alloc)`选择了第二个函数模板而非我们的备用函数，其结果仍然是在下一阶段的编译中出现size函数的错误，从这里就能更清晰地看出指针和`std::alloctor`两者在上一节出现的错误的差异。



## 表达式SFINAE与decltype

**【函数声明的局限】**

想要找出并使用正确地表达式来“筛选”出用于特定条件下的函数模板并不总是那么容易。例如，对于函数模板len：

```c++
template<typename T>
typename T::size_type len(const T &arg){
	return arg.size();
}
```

如果我们想要让函数模板len在函数参数的类型T中存在类型成员`size_type`但不存在成员函数`size()`时被忽略，那么仅凭上述的声明是无法做到的，因为在声明中没有体现出任何形式的对于T的成员函数`size()`的使用。我们知道，类型替换(substitution)阶段仅对函数模板的声明执行推断和匹配，不会涉及到函数体，因此我们在函数体中的表达式`arg.size()`在替换阶段并不能起到帮助编译器判断的作用。因此，对于以下语句：

```c++
std::allocator<int> alloc;
len(alloc);    //错误，函数模板len虽然被选中，没有allocator没有成员函数size可供调用
```

类型`std::allocator`拥有类型成员`size_type`，因此它可以通过替换阶段的检查，所以对于allocator，函数模板len被选中了，但在随后的实例化阶段中，编译器发现allocator不存在成员函数`size`，随即报错。

**【使用decltype和逗号表达式实现替换阶段的检查】**

下方是解决函数声明的局限问题的一个通用模式：

1. 通过**后置返回类型**的语法指定函数的返回值类型(以auto替代返回类型，并在函数声明末尾使用操作符`->`指定返回类型)
2. 使用`decltype`和逗号操作符定义返回类型
3. 将所有在函数中需要使用的表达式使用逗号操作符列出，形成一个逗号表达式，并将最后一个表达式之前的每个表达式的值都强制转换为`void`类型的值
4. 在逗号表达式的末尾定义一个函数真正的返回值类型的对象

这里需要解释一下逗号表达式，在C/C++语言中，逗号`,`除了用作常规的语法分隔符之外，同时也是一个操作符，以其形成的表达式称为逗号表达式，该表达式的结果为最后一个逗号后的值。例如：

```c++
int i = (1, 2, 3, 4); //i的结果为4
```

这条语句中，逗号表达式`1, 2, 3, 4`的结果为`4`，之所以需要在两侧加上括号，是因为赋值操作符`=`的优先级更高，为了让逗号表达式先执行运算，因此才加上括号，否则i的值就是1，而后面剩余部分的`,2 ,3, 4`将被视为语法错误。

让我们回到之前的问题中，按照上面提到的办法，我们将函数模板len改写为下面的样子：

```c++
template<typename T>
auto len(const T &arg) -> decltype((void)(arg.size()), typename T::size_type()){
	return arg.size();
}
```

然后，我们再执行下面的例子：

```c++
std::allocator<int> alloc;
std::vector<int> vec;

len(alloc);  //在替换阶段提示错误：allocator没有成员size
len(vec);    //OK
```

这一次，编译器成功在类型替换阶段就提示了错误。这个办法的本质是借助`decltype`和逗号表达式，将原本只能存在于函数体中的各种表达式提前融入到了函数声明中，使得编译器在类型替换阶段就能提前检查这些表达式的合法性。

**【细节探讨】**

使用decltype和逗号表达式定义的函数模板len比较复杂，其中的一些细节我们列举如下：

* decltype也能用在auto的位置，为什么必须使用后置返回类型语法？

因为我们需要让编译器检查的表达式往往和函数参数有关，而后置返回类型因为定义于函数参数列表之后，因此可以访问到函数参数

* 为什么创建对象时没有使用列表初始化的语法？

因为列表初始化语法使用的符号`{}`与函数体的定界符`{}`相同，会引发歧义，因此需要使用`T::size_type()`而非`T::size_type{}`

* 将逗号表达式内的表达式的值转换为void的原因？

这是为了避免因为用户定义的重载逗号操作符导致的推断结果与预期不符，例如：

```c++
struct RealType{};
struct UserDef{
	int operator,(const RealType &rt){
		return 0;
	}
};

using type = decltype(UserDef(),RealType());
std::cout << typeid(type).name() << std::endl; //int
```

在这个例子中，我们的预期是将type推断为`RealType`，但实际的推断结果却是`int`，这是因为UserDef类型重载了逗号操作符，因此对于逗号表达式`UserDef(),RealType()`，实际上是调用了UserDef重载的逗号操作符，即`UserDef().operator,(RealType())`，而该函数的返回类型为int，从而使得该逗号表达式的结果为int，最终导致decltype推断的类型为int。而将表达式的结果转换为void的目的就是为了避免这种情况，毕竟用户无法为void类型重载逗号操作符，从而确保逗号操作符维持默认的语义。

```c++
using type = decltype((void)UserDef(),RealType());
std::cout << typeid(type).name() << std::endl; //RealType
```



## 注：

1. 回落(fallback)方案是指用于“保底”的方案，当尝试了所有更优的方案仍不能解决问题时，才对该问题采用回落方案

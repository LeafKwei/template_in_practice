# 《SFINAE》
## SFINAE





## SFINAE与重载





## 表达式SFINAE与decltype

**【函数声明的局限】**

想要找出并使用正确地表达式来“筛选”出用于特定条件下的函数模板并不总是那么容易。例如，对于函数模板len：

```c++
template<typename T>
typename T::size_type len(const T &arg){
	return arg.size();
}
```

如果我们想要让函数模板len在函数参数的类型T中存在类型成员`size_type`但不存在成员函数`size()`时被忽略，那么仅凭上述的声明是无法做到的，因为在声明中没有体现出任何形式的对于T的成员函数`size()`的使用。我们知道，类型替换(substitution)阶段仅对函数模板的声明(declaration)执行推断和匹配，不会涉及到函数体(function body)，因此我们在函数体中的表达式`arg.size()`在替换阶段并不能起到帮助编译器判断的作用。因此，对于以下语句：

```c++
std::allocator<int> alloc;
len(alloc);    //错误，函数模板len虽然被选中，没有allocator没有成员函数size可供调用
```

类型`std::allocator`拥有类型成员`size_type`，因此它可以通过替换阶段的检查，所以对于allocator，函数模板len被选中了，但在随后的实例化阶段中，编译器发现allocator不存在成员函数`size`，随即报错。

**【使用decltype和逗号表达式实现替换阶段的检查】**

下方是解决函数声明的局限问题的一个通用模式：

1. 通过**后置返回类型**的语法指定函数的返回值类型(以auto替代返回类型，并在函数声明末尾使用操作符`->`指定返回类型)
2. 使用`decltype`和逗号操作符定义返回类型
3. 将所有在函数中需要使用的表达式使用逗号操作符列出，形成一个逗号表达式，并将最后一个表达式之前的每个表达式的值都强制转换为`void`类型的值
4. 在逗号表达式的末尾定义一个函数真正的返回值类型的对象

这里需要解释一下逗号表达式，在C/C++语言中，逗号`,`除了用作常规的语法分隔符之外，同时也是一个操作符，以其形成的表达式称为逗号表达式，该表达式的结果为最后一个逗号后的值。例如：

```c++
int i = (1, 2, 3, 4); //i的结果为4
```

这条语句中，逗号表达式`1, 2, 3, 4`的结果为`4`，之所以需要在两侧加上括号，是因为赋值操作符`=`的优先级更高，为了让逗号表达式先执行运算，因此才加上括号，否则i的值就是1，而后面剩余部分的`,2 ,3, 4`将被视为语法错误。

让我们回到之前的问题中，按照上面提到的办法，我们将函数模板len改写为下面的样子：

```c++
template<typename T>
auto len(const T &arg) -> decltype((void)(arg.size()), typename T::size_type()){
	return arg.size();
}
```

然后，我们再执行下面的例子：

```c++
std::allocator<int> alloc;
std::vector<int> vec;

len(alloc);  //在替换阶段提示错误：allocator没有成员size
len(vec);    //OK
```

这一次，编译器成功在类型替换阶段就提示了错误。这个办法的本质是借助`decltype`和逗号表达式，将原本只能存在于函数体中的各种表达式提前融入到了函数声明中，使得编译器在类型替换阶段就能提前检查这些表达式的合法性。

**【细节探讨】**

使用decltype和逗号表达式定义的函数模板len比较复杂，其中的一些细节我们列举如下：

* decltype也能用在auto的位置，为什么必须使用后置返回类型语法

因为我们需要让编译器检查的表达式往往和函数参数有关，而后置返回类型因为定义于函数参数列表之后，因此可以访问到函数参数

* 为什么创建对象时没有使用列表初始化的语法

因为列表初始化语法使用的符号`{}`与函数体的定界符`{}`相同，会引发歧义，因此需要使用`T::size_type()`而非`T::size_type{}`

* 将逗号表达式内的表达式的值转换为void的原因

这是为了避免因为用户定义的重载逗号操作符导致的推断结果与预期不符，例如：

```c++
struct RealType{};
struct UserDef{
	int operator,(const RealType &rt){
		return 0;
	}
};

using type = decltype(UserDef(),RealType());
std::cout << typeid(type).name() << std::endl; //int
```

在这个例子中，我们的预期是将type推断为`RealType`，但实际的推断结果却是`int`，这是因为UserDef类型重载了逗号操作符，因此对于逗号表达式`UserDef(),RealType()`，实际上是调用了UserDef重载的逗号操作符，即`UserDef().operator,(RealType())`，而该函数的返回类型为int，从而使得该逗号表达式的结果为int，最终导致decltype推断的类型为int。而将表达式的结果转换为void的目的就是为了避免这种情况，毕竟用户无法为void类型重载逗号操作符，从而确保逗号操作符维持默认的语义。

```c++
using type = decltype((void)UserDef(),RealType());
std::cout << typeid(type).name() << std::endl; //RealType
```


# 《模板参数声明的建议》

正如我们在前面的章节中了解到的那样，我们有不同的方式去声明依赖于模板参数的函数参数：

* 将参数声明为按值传递(pass by value)

这个方式简单，它会退化字符串字面量和原始数组，但是对于大型对象，它无法提供最佳的性能(会有拷贝开销)。

* 将参数声明为按引用传递(pass by reference)

对于大型对象，这个方式通常可以提供更佳的性能(避免了大型对象的拷贝)，特别是当我们在传递：

**a.**一个已存在的对象(左值)到左值引用时

**b.**一个临时对象(纯右值)或者是被移动语义标记为可移动的对象(将亡值)到右值引用时

**c.**以上各种对象到转发引用时

因为按引用传递不会退化参数，因此我们需要特别关注传递字符串字面量或者其他原始数组的情况。对于转发引用，我们也需关注模板参数被推断为引用类型的情况。



**【通用的建议】**

声明函数模板参数时，可以参考下面的这些建议：

1. 默认情况下应该将参数声明为按值传递(T arg)，这种方式简单并且一般能正常工作，即使是对于字符串字面量而言。对于小型对象、临时对象和可移动对象，这种方式的性能表现也不错。当传递大型对象时，调用者可以考虑使用`std::ref`或`std::cref`来避免大型对象的拷贝所产生的昂贵开销
2. 如果有更好的理由，那么尝试下面的这些办法：

**a.**如果想要修改传递的对象或者让某个对象被外部修改，那么应该将参数声明为非const引用(T &arg)，除非你打算使用指针传递参数。然而，我们可能需要考虑使用某种方式规避const对象被传递进来的情况

**b.**如果函数模板用于转发参数，则使用完美转发。这意味着我们应该将参数声明为转发引用，并且在适当的位置使用`std::forward`。考虑使用`std::decay`或`std::common_type`去“统一”不同的类型(例如字符串字面量和原始数组)

**c.**如果性能是关键，并且可以预见高开销的大型对象会被传递给函数模板，则将参数声明为const引用



**【避免过度泛化】**

在实践中，函数模板通常不会无条件地用于任意的参数类型，相反，我们会为函数模板添加某些约束，以缩小它可以处理的类型范围。举个例子，如果我们知道某个函数模板接收的参数只会是T类型的vector，那么将参数声明得太过泛化反而不好，因为可能产生某些意料之外的副作用。更好的办法是使用下方的这个声明：

```c++
template<typename T>
void foo(const std::vector<T> &v){
	/* whatever */
}
```

通过参数v的声明，我们可以确保类型参数T不会被推断为引用类型，因为vector不能使用引用类型作为元素类型。此外，我们也相当清楚，传递一个vector很可能会造成昂贵的开销，因为vector的拷贝构造函数会创建一个其内部所有元素的一个拷贝。由于这个原因，在实际情况下，我们不太可能声明一个像参数v这样的按值传递的vector参数。



**【std::make_pair的例子】**

`std::make_pair`是一个证明不同参数传递方式的陷阱的好例子，在最初的C++98标准中，make_pair的参数被声明为按引用传递以避免无意义的拷贝：

```c++
template<typename T1, typename T2>
pair<T1, T2> make_pair(const T1 &a, const T2 &b){
	return pair<T1, T2>(a, b);
}
```

如果我们将pair用于不同长度的字符串字面量或者原始数组，这个版本就会引发严重的问题。

作为解决办法，在C++03标准中，make_pair被修改为了按值传递：

```c++
template<typename T1, typename T2>
pair<T1, T2> make_pair(T1 a, T2 b){
	return pair<T1, T2>(a, b);
}
```

值传递的版本虽然可以解决字符串字面量和原始数组的问题，但是对于以按值传递的形式声明的参数，编译器在根据传递的参数推断其类型时，会剥离掉类型中的修饰符(例如const)，这就可能产生未定义行为，例如我们传递了一个`const char*`类型的指针，但编译器推断出的T1类型为`char*`，这就使得pair中保存的指针从不可修改的变成了可修改的，如果我们意外地修改了指针指向的内容，就可能会产生严重的错误。

到了C++11版本，make_pair需要支持移动语义，因此参数必须改写为转发引用，make_pair的声明也大致变成了下面的样子：

```c++
template<typename T1, typename T2>
constexpr pair<typename decay<T1>::type, typename decay<T2>::type>
make_pair(T1 &&a, T2 &&b){
	return pair<typename decay<T1>, typename decay<T2>>(
		forward<T1>(a),
        forward<T2>(b)
	);
}
```

完整的实现更加复杂，为了支持`std::ref`和`std::cref`，make_pair还需要将`std::reference_wrapper`对象解包为实际引用。目前，C++标准在多个地方都使用了类似的方式完美地转发被传递的参数，并且经常会结合`std::decay`使用。



**【decay和common_type】**


# 《模板参数声明的建议》

正如我们在前面的章节中了解到的那样，我们有不同的方式去声明依赖于模板参数的函数参数：

* 将参数声明为按值传递(pass by value)

这个方式简单，它会退化字符串字面量和原始数组，但是对于大型对象，它无法提供最佳的性能(会有拷贝开销)。

* 将参数声明为按引用传递(pass by reference)

对于大型对象，这个方式通常可以提供更佳的性能(避免了大型对象的拷贝)，特别是当我们在传递：

**a.**一个已存在的对象(左值)到左值引用时

**b.**一个临时对象(纯右值)或者是被移动语义标记为可移动的对象(将亡值)到右值引用时

**c.**以上各种对象到转发引用时

因为按引用传递不会退化参数，因此我们需要特别关注传递字符串字面量或者其他原始数组的情况。对于转发引用，我们也需关注模板参数被推断为引用类型的情况。



**【通用的建议】**

声明函数模板参数时，可以参考下面的这些建议：

1. 默认情况下应该将参数声明为按值传递(T arg)，这种方式简单并且一般能正常工作，即使是对于字符串字面量而言。对于小型对象、临时对象和可移动对象，这种方式的性能表现也不错。当传递大型对象时，调用者可以考虑使用`std::ref`或`std::cref`来避免大型对象的拷贝所产生的昂贵开销
2. 如果有更好的理由，那么尝试下面的这些办法：

**a.**如果想要修改传递的对象或者让某个对象被外部修改，那么应该将参数声明为非const引用(T &arg)，除非你打算使用指针传递参数。然而，我们可能需要考虑使用某种方式规避const对象被传递进来的情况

**b.**如果函数模板用于转发参数，则使用完美转发。这意味着我们应该将参数声明为转发引用，并且在适当的位置使用`std::forward`。考虑使用`std::decay`或`std::common_type`去“统一”不同的类型(例如字符串字面量和原始数组)

**c.**如果性能是关键，并且可以预见高开销的大型对象会被传递，则将参数声明为const引用



**【避免过度泛化】**

在实践中，函数模板通常不会无条件地用于任意的参数类型，相反，我们会为函数模板添加某些约束，以缩小它可以处理的类型范围。举个例子，如果我们知道某个函数模板接收的参数只会是T类型的vector，那么将参数声明得太过泛化反而不好，因为可能产生某些意料之外的副作用。更好的办法是使用下方的这个声明：

```c++
template<typename T>
void foo(const std::vector<T> &v){
	/* whatever */
}
```





**【std::make_pair的例子】**
# 《使用偏特化选择执行路径》
编译时运算有一个有趣的用途——借助偏特化可以在编译时选择不同的实现。例如，我们先编写一个在编译时可以判断数字是否是偶数的constexpr函数：

```c++
constexpr bool isEven(unsigned num){
    return num % 2 == 0;
}
```

然后，假设我们现在有一个函数模板select，它需要根据参数中的数组长度是否是一个偶数来从类Evener和Odder中选择一个创建对象，一般来说，我们会在select内部通过一个if语句来判断数组长度是否是一个偶数，然后创建相应的对象，例如：

```c++
struct Evener{ Evener(){ std::cout << "Evener" << std::endl; } };
struct Odder{ Odder(){ std::cout << "Odder" << std::endl; } };

template<typename T, std::size_t SZ>
void select(const T (&arr)[SZ]){
	if(isEven(SZ)){  //如果是偶数，创建Evenver
        Evener evener;
    }else{           //否则创建Odder
        Odder odder;
    }
}
```

现在我们来看一下另一种办法——通过偏特化在编译时选择不同实现。首先创建一个类模板Num，并将Odder和Evener分别作为该模板的偏特化版本进行实现：

```c++
/* 通用模板 */
template<std::size_t SZ, bool iseven>
struct Num{};

/* 用于偶数的偏特化 */
template<std::size_t SZ>
struct Num<SZ, true>{ Num(){ std::cout << "Evener: " << SZ << std::endl; } };

/* 用于奇数的偏特化 */
template<std::size_t SZ>
struct Num<SZ, false>{ Num(){ std::cout << "Odder: " << SZ << std::endl; } };
```

在类模板Num中我们额外声明了一个非类型参数`bool iseven`，并且基于该参数实现了两个不同的偏特化版本。这意味着当iseven为true时，编译器会选择用于偶数的`Num<SZ,true>`版本，iseven为false时，编译器会选择用于奇数的`Num<SZ,false>`版本。而在编译时根据SZ动态选择实现的关键就在于isEven函数，它是一个constexpr函数，因此可以在编译时求值(当然，前提是参数是常量表达式)，我们可以将`isEven(SZ)`作为Num的第二个非类型参数，这样就可以实现在编译时根据isEven的求值结果选择不同的Num实现。

```c++
template<typename T, std::size_t SZ>
void select(const T (&arr)[SZ]){
	Num<SZ, isEven(SZ)> num; //可以根据SZ是否是偶数在编译时选择不同实现
}
```

更近一步，我们还可以将iseven修改为非类型默认参数，即：

```c++
template<std::size_t SZ, bool = isEven(SZ)>
struct Num{};
```

由于isEven是constexpr函数，因此也可以用于非类型参数默认值的初始化。之后我们只需使用`Num<SZ>`就能达到相同的目的。

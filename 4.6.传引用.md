# 《传引用》

## 按const引用传递

为了避免不必要的拷贝，我们在传递非临时对象(nontemporary objects)时，可以使用const引用(constant references)，例如：

```c++
template<typename T>
void printCR(const T &arg){
	/* whatever */
}
```

在这种情况下，传递一个对象永远不会发生拷贝(无论拷贝的开销如何)：

```c++
std::string str("Hello");
std::string returnString();

printCR(str);                 //不会发生拷贝
printCR(std::string("Hello"));//不会发生拷贝
printCR(returnString());      //不会发生拷贝
printCR(std::move(str));      //不会发生拷贝
```

即使我们传递的是一个int值，虽然它的拷贝开销极其细微，但仍然不会被拷贝。对于调用`printCR(100)`，printCR会被实例化为：

```c++
void printCR(const int &arg){
	/* whatever */
}
```

在底层，通过引用传递一个参数实际上是通过传递参数的地址来实现的，由于地址的编码十分紧凑(数据量低)，因此从调用者(caller)传递一个地址到被调用者(callee)是十分高效的(相比于拷贝一整个对象而言)。然而，当编译器在编译调用者的代码时，传递一个地址可能会对编译器带来一些不确定性——编译器无法得知被调用者会使用这个地址做什么事。理论上，被调用者可以修改通过这个地址可到达的任何值(可到达是指不仅包括这个地址之上的对象，还有通过该对象可间接访问的其他对象)。这意味着编译器只能假设所有已经被缓存的值会在这次调用之后变得无效(因为该值有可能在调用过程中被修改)，重新加载这些值的开销可能会相当高。

**【传递引用不会发生退化】**

当通过引用传递参数时，这些参数不会发生退化(decay)，也就是说数组不会被转换为指针，而像const、volatile这些限定符也不会被移除。然而，由于函数模板的参数被声明为`const T&`，因此模板参数T被推断出的类型将不具有const属性，例如：

```c++
template<typename T>
void printCR(const T &arg){
	/* whatever */
}

const std::string str("Hello");
printCR(str);   //T被推断为std::string而非const std::string
```

如果此时在printCR内部以`T`为类型声明局部变量，那么该变量将是`std::string`类型而非`const std::string`类型。



## 按非const引用传递

如果你想要通过传递的参数携带返回值(例如将该参数作为一个out或in-out参数)，那么就必须使用非const的引用传递该参数(除非你打算通过指针传递)，同样的，使用非const引用也不会产生任何拷贝，被调用者的参数只是获得了对被引用对象的直接访问能力。考虑如下的例子：

```c++
template<typename T>
void outR(T &arg){
	/* whatever */
}
```

注意，不能使用临时对象(纯右值，prvalue)或者是一个被`std::move`转换过的对象(将亡值，xvalue)初始化或者传递给一个非const引用，否则无法通过编译。以outR为例：

```c++
std::string str("Hello");
std::string returnString("Hello");

outR(str);  //OK，T被推断为std::string
outR(std::string("Hello")); //错误，不允许传递prvalue
outR(returnString());       //错误，不允许传递prvalue
outR(std::move(str));       //错误，不允许传递xvalue
```

对于模板而言，非const引用有一点棘手。如果我们传递一个具有const属性的对象，那么类型推断机制会导致参数arg被推断为一个带有const属性的引用声明，这意味着在原本只应该传递左值(lvalue)的地方，在这之后可以传递右值(rvalue)了。

```c++
const std::string str("Hello");
outR(str);  //OK，T被推断为const std::string

outR(std::string("Hello")); //OK，此时arg是一个const引用，可以接受prvalue
outR(returnString());       //OK，此时arg是一个const引用，可以接受prvalue
outR(std::move(str));       //OK，此时arg是一个const引用，可以接受xvalue
```

当然，此时在这个函数模板内部，任何尝试修改参数arg所引用对象的操作都将导致错误。如果想要避免这种情况发生，可以采取以下手段：

* 通过静态断言触发编译时错误

```c++
template<typename T>
void outR(T &arg){
	static_assert(!std::is_const<T>::value, "Out parameter 'arg' is const.");
	/* whatever */
}
```

* 通过std::enable_if或concept禁用模板

```c++
template<typename T, typename = std::enable_if_t<!std::is_const<T>::value>>
void outR(T &arg){
	/* whatever */
}
```



## 按转发引用传递

使用按引用传递的原因之一是可以通过转发引用(forwarding reference)完美转发参数。转发引用的定义和右值引用很相似，但不同之处在于定义右值引用使用的是一个具体的类型，而转发引用则使用的是一个模板参数，虽然外表相似，但是转发引用却拥有和右值引用完全不同的特殊规则。考虑如下例子：

```c++
template<typename T>
void forwardR(T &&arg){
    /* whatever */
}
```

我们可以传递任何对象给一个转发引用，无论这些对象具有怎样的属性(例如const或是rvalue)，并且如同其他引用一样，通过转发引用来接收对象也不会产生任何拷贝：

```c++
int arr[] = {1, 2, 3};
std::string str("Hello");

forwardR(str);                   //lvalue OK，T被推断为std::string，arg为std::string&
forwardR(std::string("Hello"));  //prvalue OK，T被推断为std::string，arg为std::string&&
forwardR(returnString());        //prvalue OK，T被推断为std::string，arg为std::string&&
forwardR(std::move(str));        //xvalue OK，T被推断为std::string，arg为std::string&&
forwardR(arr);                   //lvalue OK，T被推断为int(&)[3]，arg也为int(&)[3]
```

转发引用将始终保持着和被传递的参数一致的类型和属性。这套特殊规则有时也会给我们带来一些意外的情况：

```c++
int arr[] = {1, 2, 3};
const std::string str("Hello");

forwardR(str);     //T被推断为const std::string&
forwardR("Hello"); //T被推断为const char(&)[6]
forwardR(arr);     //T被推断为int(&)[3]
```

在以上的每种情况中，forwardR的参数arg都拥有着与我们传递的参数完全一致的类型，而这也是唯一的，通过一个(转发引用)参数就可以区分出以上三种不同情况的办法。这可能让我们觉得转发引用几乎是完美的，但天下没有免费的午餐，下面是模板参数T唯一会被推断为引用类型的情况，其结果是，如果我们尝试使用T声明一个未初始化的变量，那么将导致错误的发生：

```c++
template<typename T>
void forwardR(T &&arg){
	T x;
	/* whatever */
}

int n = 114;

forwardR(114); //OK，T被推断为int，arg为int&&
forwardR(n);   //错误，T被推断为int&，arg为int&
```

对于`forwardR(n)`，此时模板参数T被推断为`int&`，那么在forwardR内部，我们正尝试使用`int&`声明一个变量x，并且没有进行初始化，而未经初始化的引用将会引发错误。


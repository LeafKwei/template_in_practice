# 《模板元编程和编译时计算》

## 模板元编程

**【使用模板实现编译时计算】**

模板在编译时期实例化，这个特性使得一些C++语言特性可以和模板的实例化过程相结合，从而在C++语言内部衍生出一种原始的递归式“编程语言”。因此，模板可以被用来在编译时期(compile-time)“计算某个问题”。下面的这个例子可以在编译时期计算出一个给定的数字是否是一个素数(质数)：

```c++
template<unsigned P, unsigned D>
struct DoIsPrime { static constexpr bool value = (P % D != 0) && (DoIsPrime<P, D-1>::value); };

template<unsigned P>
struct DoIsPrime<P,2> { static constexpr bool value = (P % 2 != 0); };

template<unsigned P>
struct IsPrime { static constexpr bool value = DoIsPrime<P, P/2>::value; };

/* 下方的这些特例用于避免无限递归 */
template<>
struct IsPrime<0> { static constexpr bool value = false; };

template<>
struct IsPrime<1> { static constexpr bool value = false; };

template<>
struct IsPrime<2> { static constexpr bool value = true; };

template<>
struct IsPrime<3> { static constexpr bool value = true; };
```

按照质数的判断规则，我们需要计算给定的数字P是否能被2到P/2之间的任何一个数整除，因此模板`DoIsPrime`声明了两个非类型参数P和D，分别接收数字P和除数。然后，在DoIsPrime的内部，关键字`constexpr`将value声明为了一个编译时常量，它的初始值必须是一个能在编译时期计算的值。在value的右侧，表达式`(P % D != 0) && (DoIsPrime<P, D-1>::value)`是整个运算过程的关键，通过将P与除数D进行模运算，如果结果不为0就说明P无法被D整除，紧接着我们继续以P和除数D的下一个数字`D-1`递归实例化DoIsPrime，如此循环往复直到计算到最后一个除数。

DoIsPrime的偏特化版本`struct DoIsPrime<P,2>`用作递归的终止条件，当D因为递归实例化递减到2时，编译器将会选择我们的偏特化版本，从而实现终止递归。

模板`IsPrime`作为DoIsPrime入口，用于开启递归并生成最初的除数。由于模板的递归条件会在D递减到2时才触发，而除数是通过`P/2`得到的，因此对于一些该运算结果小于2的数字，我们需要添加特例来解决，即`IsPrime<0> `等特例化模板。

**【IsPrime的使用】**

假设我们想要判断9是否是一个质数：

```c++
constexpr bool isprime = IsPrime<9>::value;
```

其中，`IsPrime<9>::value`实例化后可看作是：

```c++
DoIsPrime<9, 9/2>::value
```

然后，该模板继续递归实例化并等效为：

```c++
(9 % 4 != 0) && (DoIsPrime<9, 4-1>::value)
```

然后，继续递归实例化并等效为：

```c++
(9 % 4 != 0) && ((9 % 3 != 0) && DoIsPrime<9, 3-1>::value))
```

至此，`DoIsPrime<9, 3-1>::value`匹配偏特化的`DoIsPrime<2>`，递归结束。最终实例化并等效为：

```c++
(9 % 4 != 0) && ((9 % 3 != 0) && (9 % 2 != 0)))
```



## 编译时计算

**【constexpr】**

C++11引入了一个新的限定符`constexpr`，极大地简化了编译时计算的方式。具体来说，给定一个适当的输入，constexpr函数可以在编译时进行运算并求值。但是，在C++11时，constexpr函数有着严格的限制(函数内容基本被限制为只允许一条return语句存在)，这些限制大部分在C++14时得到了改善。当然，为了能够正确地求值，constexpr函数仍然要求所有的计算步骤在编译时都是可用和有效的。在目前，像是堆内存分配(heap allocation)或者抛出异常等操作不能用作编译时计算。

上一节中判断质数的例子在C++11中可以实现如下：

```c++
constexpr bool doIsPrime(unsigned p, unsigned d){
    return (d == 2) ? (p % 2 != 0) : (p % d != 0) && doIsPrime(p, d-1);
}

constexpr bool isPrime(unsigned p){
    return (p < 4) ? (p / 2) : doIsPrime(p, p/2);
}
```

由于constexpr函数内容仅允许存在一条语句，因此我们只能使用条件操作符`?:`实现选择结构，并且仍然需要通过递归来迭代完所有的被除数。好在使用的语法是传统的C++函数代码，相比于前一个例子中依赖模板实例化的实现更能让人接受。

**【C++14的改变】**

在C++14以后，大部分的控制结构都可以在constexpr函数中使用，并且函数内容也允许多条语句的存在。因此不必再写冗长的模板代码或者是难以阅读的单行函数，现在我们可以直接使用普通的循环：

```c++
constexpr bool isPrime(unsigned p){
	for(unsigned i = 2; i <= p/2; i++){
        if(p % 2 == 0){
            return false;
        }
    }
    
    return p > 1; //最小的质数为2，因此要排除0、1
}
```

需要注意，constexpr函数能够在编译时运算，但它并不是必须在编译时运算。在一些必须要求编译时常量的上下文中(例如数组长度或者是constexpr表达式)，编译器会尝试在编译时期对一个constexpr的调用求值，并在无法求值的情况下提示错误(constexpr函数在最后必须返回一个常量)；在其他上下文中，编译器可能会也可能不会在编译时对constexpr函数求值，此时即使发生了上述无法求值的错误，编译器也不会产生错误提示，而是将求值操作保留到运行时进行。

```c++
constexpr bool b = isPrime(9); //constexpr表明b是编译期常量，因此编译器会对isPrime(9)进行编译时求值
```

而对于如下例子：

```c++
bool nineIsPrime(){
	return isPrime(9);
}
```

编译器可能会也可能不会在编译时求值。此外，在下方的例子中：

```c++
int x;
//对x赋值等操作
//...
bool b = isPrime(x);
```

`isPrime(x)`将会在运行时求值，因为x的值只有在运行时才能得知。



## 补充：const与constexpr

**【constexpr的作用】**





**【const和constexpr区别】**






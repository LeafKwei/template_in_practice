# 《模板元编程和编译时计算》

## 模板元编程

**【使用模板实现编译时计算】**

模板在编译时期实例化，这个特性使得一些C++语言特性可以和模板的实例化过程相结合，从而在C++语言内部衍生出一种原始的递归式“编程语言”。因此，模板可以被用来在编译时期(compile-time)“计算某个问题”。下面的这个例子可以在编译时期计算出一个给定的数字是否是一个素数(质数)：

```c++
template<unsigned P, unsigned D>
struct DoIsPrime { static constexpr bool value = (P % D != 0) && (DoIsPrime<P, D-1>::value); };

template<unsigned P>
struct DoIsPrime<P,2> { static constexpr bool value = (P % 2 != 0); };

template<unsigned P>
struct IsPrime { static constexpr bool value = DoIsPrime<P, P/2>::value; };

/* 下方的这些特例用于避免无限递归 */
template<>
struct IsPrime<0> { static constexpr bool value = false; };

template<>
struct IsPrime<1> { static constexpr bool value = false; };

template<>
struct IsPrime<2> { static constexpr bool value = true; };

template<>
struct IsPrime<3> { static constexpr bool value = true; };
```

按照质数的判断规则，我们需要计算给定的数字P是否能被2到P/2之间的任何一个数整除，因此模板`DoIsPrime`声明了两个非类型参数P和D，分别接收数字P和除数。然后，在DoIsPrime的内部，关键字`constexpr`将value声明为了一个编译时常量，它的初始值必须是一个能在编译时期计算的值。在value的右侧，表达式`(P % D != 0) && (DoIsPrime<P, D-1>::value)`是整个运算过程的关键，通过将P与除数D进行模运算，如果结果不为0就说明P无法被D整除，紧接着我们继续以P和除数D的下一个数字`D-1`递归实例化DoIsPrime，如此循环往复直到计算到最后一个除数。

DoIsPrime的偏特化版本`struct DoIsPrime<P,2>`用作递归的终止条件，当D因为递归实例化递减到2时，编译器将会选择我们的偏特化版本，从而实现终止递归。

模板`IsPrime`作为DoIsPrime入口，用于开启递归并生成最初的除数。由于模板的递归条件会在D递减到2时才触发，而除数是通过`P/2`得到的，因此对于一些该运算结果小于2的数字，我们需要添加特例来解决，即`IsPrime<0> `等特例化模板。

**【IsPrime的使用】**

假设我们想要判断9是否是一个质数：

```c++
constexpr bool isprime = IsPrime<9>::value;
```

其中，`IsPrime<9>::value`实例化后可看作是：

```c++
DoIsPrime<9, 9/2>::value
```

然后，该模板继续递归实例化并等效为：

```c++
(9 % 4 != 0) && (DoIsPrime<9, 4-1>::value)
```

然后，继续递归实例化并等效为：

```c++
(9 % 4 != 0) && ((9 % 3 != 0) && DoIsPrime<9, 3-1>::value))
```

至此，`DoIsPrime<9, 3-1>::value`匹配偏特化的`DoIsPrime<2>`，递归结束。最终实例化并等效为：

```c++
(9 % 4 != 0) && ((9 % 3 != 0) && (9 % 2 != 0)))
```



## 编译时计算

**【constexpr】**

C++11引入了一个新的限定符`constexpr`，极大地简化了编译时计算的方式。具体来说，给定一个适当的输入，constexpr函数可以在编译时进行运算并求值。但是，在C++11时，constexpr函数有着严格的限制(函数内容基本被限制为只允许一条return语句存在)，这些限制大部分在C++14时得到了改善。当然，为了能够正确地求值，constexpr函数仍然要求所有的计算步骤在编译时都是可用和有效的。在目前，像是堆内存分配(heap allocation)或者抛出异常等操作不能用作编译时计算。

上一节中判断质数的例子在C++11中可以实现如下：

```c++
constexpr bool doIsPrime(unsigned p, unsigned d){
    return (d == 2) ? (p % 2 != 0) : (p % d != 0) && doIsPrime(p, d-1);
}

constexpr bool isPrime(unsigned p){
    return (p < 4) ? (p / 2) : doIsPrime(p, p/2);
}
```

由于constexpr函数内容仅允许存在一条语句，因此我们只能使用条件操作符`?:`实现选择结构，并且仍然需要通过递归来迭代完所有的被除数。好在使用的语法是传统的C++函数代码，相比于前一个例子中依赖模板实例化的实现更能让人接受。

**【C++14的改变】**

在C++14以后，大部分的控制结构都可以在constexpr函数中使用，并且函数内容也允许多条语句的存在。因此不必再写冗长的模板代码或者是难以阅读的单行函数，现在我们可以直接使用普通的循环：

```c++
constexpr bool isPrime(unsigned p){
	for(unsigned i = 2; i <= p/2; i++){
        if(p % 2 == 0){
            return false;
        }
    }
    
    return p > 1; //最小的质数为2，因此要排除0、1
}
```

需要注意，constexpr函数能够在编译时运算，但它并不是必须在编译时运算。在一些必须要求编译时常量的上下文中(例如数组长度或者是constexpr表达式)，编译器会尝试在编译时期对一个constexpr的调用求值，并在无法求值的情况下提示错误(constexpr函数在最后必须返回一个常量)；在其他上下文中，编译器可能会也可能不会在编译时对constexpr函数求值，此时即使发生了上述无法求值的错误，编译器也不会产生错误提示，而是将求值操作保留到运行时进行。

```c++
constexpr bool b = isPrime(9); //constexpr表明b是编译期常量，因此编译器会对isPrime(9)进行编译时求值
```

而对于如下例子：

```c++
bool nineIsPrime(){
	return isPrime(9);
}
```

编译器可能会也可能不会在编译时求值。此外，在下方的例子中：

```c++
int x;
//对x赋值等操作
//...
bool b = isPrime(x);
```

`isPrime(x)`将会在运行时求值，因为x的值只有在运行时才能得知。



## 补充：const与constexpr

**【constexpr的作用】**

`constexpr`可以将变量或函数标识为常量表达式。常量表达式是指可以由编译器在编译时求值的表达式。常量表达式通常由整数、浮点数、枚举值构成，我们可以使用运算符或constexpr函数将这些成分组合在一起形成一个常量表达式。常量表达式的组成成分必须是在编译时已知的值(确切地说，是编译器已经知道的值)，并且常量表达式中进行的运算不能有副作用(例如修改了某个变量)，换句话说，在常量表达式求值时，不能影响到程序任何部分的状态。以下是constexpr的使用示例：

```c++
constexpr int size = 100;
constexpr int weight = size * 2;  //OK，size是常量表达式

constexpr int width(int i){
	return i * 21;
}

constexpr int height(){
    return width(2) * 5;  //OK，2是常量表达式，因此width(2)是常量表达式
}
```

标识为constexpr的变量将被视为常量表达式，因此其右侧的初始化器也必须是一个常量表达式。constexpr函数较为特殊，如我们前面提到的那样，当constexpr函数被用于需要常量表达式的上下文时，该函数必须满足常量表达式的要求，其他情况下则被当作一个普通函数在运行时求值。

如果一个变量被标识为constexpr，但初始化它的表达式不是一个常量表达式，那么编译器将提示错误：

```c++
int size = 100;
constexpr int weight = size * 2;  //错误，size不是常量表达式
```

虽然在我们看来，编译器应该可以判断size的值是100，但在大型程序中，想要追踪一个变量在当前时刻的值是多少非常困难，因此没有办法完全依赖编译器。

**【const和constexpr区别】**

`const`常用于标识某个变量不可更改，与`constexpr`不同，const修饰的变量既可以使用常量表达式初始化，也可以使用非常量表达式初始化。使用常量表达式初始化的const变量也可用于常量表达式的运算中：

```c++
const int size = 100;
constexpr int weight = size * 2;  //OK，size使用常量表达式初始化
```

**【符号化常量】**

`const`和`constexpr`最重要的用途之一是可以将常量符号化。设想一下，我们需要频繁地读取一个字符串，每次读取时都需要临时创建一个长度为128的字符数组：

```c++
char buf[128] = {0};
int nread = read(FILENO_STDIN, buf, 127);
```

如果这样的读取遍布程序各处，那么当将来的某一天需要读取的字符串长度增加到了255，我们就需要将每个位置的数组长度修改为256，这使得维护变得异常困难并且充满风险。此外，字面量形式的`128`不能清晰地表达出它的作用，当抛开数组声明后，面对一个单独的128，我们根本想不到它代表的是什么含义，是数组长度，还是某人的体重？

对于这些问题，我们应该采用const或constexpr将128这样的常量符号化，例如：

```c++
constexpr int BUF_SIZE = 128;
```

这样做的好处是：

* 将信息局部化，符号充当了常量和该常量的用户之间的中间层，发生变化时，只需要修改BUF_SIZE对应的值即可
* 为信息赋予含义，通过BUF_SIZE可以看出该常量是某个缓冲区的大小




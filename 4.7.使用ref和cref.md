# 《使用std::ref和std::cref》

从C++11开始，函数模板的调用者可以决定是以传值还是传引用的方式来传递参数。当一个函数模板声明为通过传值来获取参数时，调用者可以通过`std::ref`或`std::cref`将参数作为引用传递，例如：

```
template<typename T>
void foo(T arg){
	/* whatever */
}

std::string str("Hello");
foo(str);           //传值
foo(std::ref(str))  //传引用(实际上是传递一个引用包装器)
```

函数模板foo的函数参数声明为`T arg`，因此当我们直接传递参数str时，foo被实例化为`foo(std::string str)`，相应的，foo得到的将是str的一个拷贝。而如果使用`std::ref(str)`传递str，那么foo得到的就是str的引用。`std::ref`并没有改变函数模板foo中对于参数的处理，相反，它使用了一个小技巧：通过一个行为像引用的对象来包装传递的参数。

实际上，`std::ref`创建了一个std::reference_wrapper的包装器对象，该对象内部保存了被传递的原对象str的引用，而我们传递给foo的实际上是包装器对象。标准要求包装器对象必须支持至少一个操作：可以隐式地转换为原类型的引用。因此，只要是对原对象有效的操作，你都可以将该操作用于包装器对象，例如：

```c++
void modify(std::string &str){
	str = "World";
}

void modify(int &i){
	i = 100;
}

template<typename T>
void distribute(T arg){
	modify(arg);
}

int cnt = 0;
std::string str("Hello");
distribute(std::ref(cnt));
distribute(std::ref(str));
std::cout << cnt << std::endl; //100
std::cout << str << std::endl; //World
```

这个例子中，函数模板`distribute(T arg)`以值的形式获取参数，因此如果我们直接传递cnt或str，那么distribute得到的就是它们的拷贝，而modify函数中修改的也只是distribute中的内容，对cnt和str则无影响。当我们使用std::ref将cnt和str包装后，distribute接收到的就是包装器对象的拷贝，而其中保存的引用仍然指向的是cnt和str，当distribute将包装器对象传递给modify函数时，由于包装器对象提供了转换为原类型引用的类型转换操作符，因此编译器会为我们进行一次隐式类型转换，将包装器对象转换回cnt和str的引用，此时modify函数进行的修改就可以反应到我们的cnt和str中。
# 《为类模板声明友元函数》

**【在类模板中定义友元函数】**

想要将友元函数用于类模板，最简单的办法将是将友元函数直接定义于类模板中：

```c++
template<typename MT>
struct Message{
    MT m_msg;
    Message(const MT &msg) : m_msg(msg){}

     /* 直接在类模板中定义友元函数 */
    friend std::ostream& operator<<(std::ostream &os, Message<MT> &msg){
        os << msg.m_msg;
        return os;
    }
};
```

这种友元函数虽然定义在类模板内部，但却并不是类模板的成员函数，可以像普通的全局函数那样脱离类模板使用：

```c++
struct Message<const char*> msg{"Hello World"};
operator<<(std::cout, msg);  //也可以写为操作符形式std::cout << msg
```

**【声明与定义分离】**

如果想要先在类模板中声明友元函数，而将其定义放到其他地方进行，那么事情就会麻烦很多，我们有两种选择：第一种办法是先在类模板中声明一个友元函数模板，然后再在类模板外部定义前面声明的友元函数模板，以此实现友元函数的声明和定义分别进行：

```c++
template<typename MT>
struct Message{
    MT m_msg;
    Message(const MT &msg) : m_msg(msg){}

    template<typename U>
    friend std::ostream& operator<<(std::ostream &os, Message<U> &msg);
};

template<typename T>
std::ostream& operator<<(std::ostream &os, Message<T> &msg){
    os << msg.m_msg;
    return os;
}
```

注意，在声明友元函数模板时，我们使用的模板参数名称为U，而不是和Message一样的MT，这是因为我们在外层作用域中已经声明了模板参数MT，如果再在内层声明一个同名的模板参数，就会导致外层的模板参数被遮蔽，从而无法引用到外层的模板参数。编译器会阻止这种情况的发生。

第二种办法是通过前向声明[1]先将友元函数声明为一个函数模板，然后在类模板的内部声明一个特例化的友元函数，其特例化的模板参数为类模板的模板参数，最后在类模板外部定义友元函数模板：

```c++
/* 由于operator<<的参数会使用到Message，因此也需要对Message进行前向声明 */
template<typename MT>
struct Message;

template<typename T>
std::ostream& operator<<(std::ostream&, Message<T> &msg);

template<typename MT>
struct Message{
    MT m_msg;
    Message(const Mtype &msg) : m_msg(msg){}

    friend std::ostream& operator<<<MT>(std::ostream &os, Message<MT> &msg);
};

template<typename T>
std::ostream& operator<<(std::ostream &os, Message<T> &msg){
    os << msg.m_msg;
    return os;
}
```

在类模板的友元声明中，函数`operator<<`后紧跟的`<MT>`是函数模板的特例化标志，如果缺少了这个特例化标志，我们就只是声明了一个新的非模板友元函数。



**注：**

1. 前向声明：告知编译器此名称存在对应实体，但是完整定义在其他位置，同时也告知编译器一些必要信息(例如返回值、参数类型)
# 《通过std::enable_if禁用模板》

**【使用std::enable_if禁用模板】**

从C++11开始，标准库引入了一个工具模板std::enable_if，用于在给定编译时(compile-time)条件下忽略函数模板。例如：

```c++
template<typename T>
typename std::enable_if<(sizeof(T) == 4)>::type is32bit(){
    std::cout << "YES." << std::endl;
}
```

当表达式`(sizeof(T) == 4`的结果为false时，模板is32bit将被编译器忽略，相反，如果结果为true，那么该模板将被展开为：

```c++
void is32bit(){
    std::cout << "YES." << std::endl;
}
```

std::enable_if是一个类型萃取(type tarit)，作用是计算作为它的第一个模板参数传递的一个编译时表达式的结果，并且根据该结果产生如下作用：

1. 如果表达式为true，并且没有传递第二个模板参数，那么std::enable_if::type将表达为void，其他情况下，type将表达为第二个模板参数
2. 如果表达式为false，那么type将不会被定义，导致一个被称为SFINAE(替换失败不是一个错误)的模板特性生效，该std::enable_if表达式存在的模板将被编译器忽略，因此，我们可以通过这个特性来避免函数模板被用于与其不适配的类型

和所有的类型萃取模板一样，自C++14开始，std::enable_if存在一个对应的std::enable_if_t的别名模板，通过后者可直接代替`::type`。前面提到过，std::enable_if::type在表达式为true并且提供了第二个模板参数时会表达为第二个模板参数，在下方的代码中，我们将get32bit的模板参数T(在本例中为int)用作了std::enable_if的第二个模板参数，由于sizeof(int)的大小为4，因此表达式为true，相应的，std::enable_if::type将表达为int。

```c++
/* 使用std::enable_if_t */
template<typename T>
typename std::enable_if_t<(sizeof(T) == 4)> is32bit(){   //无需指定::type
    std::cout << "YES." << std::endl;
}

/* 将enable_if的第二个模板参数指定为类型T */
template<typename T>
typename std::enable_if<(sizeof(T) == 4), T>::type get32bit(){
    return 1000000;
}

int main(void){
    is32bit<int>();
    get32bit<int>();
}
```

对于模板is32bit，由于我们没有为std::enable_if_t指定第二个模板参数的类型，因此在`sizeof(T) == 4`为true时，std::enable_if_t将表达为void，对应的is32bit将实例化为`void is32bit()`。再来看get32bit，我们将其中的std::enable_if的第二个模板参数指定为get32bit的模板参数T，那么当`(sizeof(T) == 4)`为true时，std::enable_if::type将表达为T对应的类型，在本例中，我们将T指定为了int，那么对应的get32bit将会实例化为`int get32bit()`。

如果我们以下面的类型来调用is32bit(get32bit也是同理)，那么在编译过程中将会出错：

```c++
is32bit<double>();
```

由于double的大小为8字节，因此std::enable_if中的`sizeof(T) == 4)`为false，此时编译器将实例化另一个版本的std::enable_if，而在这个版本的std::enable_if中并未定义类型成员type，从而导致is32bit的定义不完整，编译器可以发现这个错误，随后忽略掉不完整的模板is32bit。在本例中，由于我们没有定义可以处理double类型的is32bit，因此在编译器忽略掉不完整的is32bit后，由于没有可候选的其他模板，因此报告错误。

**【更简洁地使用std::enable_if】**

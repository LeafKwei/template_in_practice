# 《通过std::enable_if禁用模板》

## 使用std::enable_if禁用模板

从C++11开始，标准库引入了一个工具模板std::enable_if，用于在给定编译时(compile-time)条件下忽略函数模板。例如：

```c++
template<typename T>
typename std::enable_if<(sizeof(T) == 4)>::type is32bit(){
    std::cout << "YES." << std::endl;
}
```

当表达式`(sizeof(T) == 4`的结果为false时，模板is32bit将被编译器忽略，相反，如果结果为true，那么该模板将被展开为：

```c++
void is32bit(){
    std::cout << "YES." << std::endl;
}
```

std::enable_if是一个类型萃取(type tarit)，作用是计算作为它的第一个模板参数传递的一个编译时表达式的结果，并且根据该结果产生如下作用：

1. 如果表达式为true，并且没有传递第二个模板参数，那么std::enable_if::type将表达为void，其他情况下，type将表达为第二个模板参数
2. 如果表达式为false，那么type将不会被定义，导致一个被称为SFINAE(替换失败不是一个错误)的模板特性生效，该std::enable_if表达式存在的模板将被编译器忽略，因此，我们可以通过这个特性来避免函数模板被用于与其不适配的类型

和所有的类型萃取模板一样，自C++14开始，std::enable_if存在一个对应的std::enable_if_t的别名模板，通过后者可直接代替`::type`。前面提到过，std::enable_if::type在表达式为true并且提供了第二个模板参数时会表达为第二个模板参数，在下方的代码中，我们将get32bit的模板参数T(在本例中为int)用作了std::enable_if的第二个模板参数，由于sizeof(int)的大小为4，因此表达式为true，相应的，std::enable_if::type将表达为int。

```c++
/* 使用std::enable_if_t */
template<typename T>
typename std::enable_if_t<(sizeof(T) == 4)> is32bit(){   //无需指定::type
    std::cout << "YES." << std::endl;
}

/* 将enable_if的第二个模板参数指定为类型T */
template<typename T>
typename std::enable_if<(sizeof(T) == 4), T>::type get32bit(){
    return 1000000;
}

int main(void){
    is32bit<int>();
    get32bit<int>();
}
```

对于模板is32bit，由于我们没有为std::enable_if_t指定第二个模板参数的类型，因此在`sizeof(T) == 4`为true时，std::enable_if_t将表达为void，对应的is32bit将实例化为`void is32bit()`。再来看get32bit，我们将其中的std::enable_if的第二个模板参数指定为get32bit的模板参数T，那么当`(sizeof(T) == 4)`为true时，std::enable_if::type将表达为T对应的类型，在本例中，我们将T指定为了int，那么对应的get32bit将会实例化为`int get32bit()`。

如果我们以下面的类型来调用is32bit(get32bit也是同理)，那么在编译过程中将会出错：

```c++
is32bit<double>();
```

由于double的大小为8字节，因此std::enable_if中的`sizeof(T) == 4)`为false，此时编译器将实例化另一个版本的std::enable_if，而在这个版本的std::enable_if中并未定义类型成员type，从而导致is32bit的定义不完整，编译器可以发现这个错误，随后忽略掉不完整的模板is32bit。在本例中，由于我们没有定义可以处理double类型的is32bit，因此在编译器忽略掉不完整的is32bit后，由于没有可候选的其他模板，因此报告错误。



## 更简洁地使用std::enable_if

不难发现，在上文中我们将std::enable_if置于返回值位置的做法导致了模板的可读性变差，为了提高模板的可读性，我们可以为模板增加一个默认模板参数，将std::enable_if::type作为默认类型，这样既可以让std::enable_if能正常触发SFINAE特性，又不会严重影响到模板代码的可读性：

```c++
template<typename T, typename=typename std::enable_if<sizeof(T) == 4>::type>
void is32bit(){
    std::cout << "YES." << std::endl;
}
```

由于我们只是将第二个模板参数作为std::enable_if的一个触发工具，并不打算真正地使用它，因此为了简洁起见，我们省略了它的参数名称。此时，如果`sizeof(T) == 4`为true，那么该模板将被展开为：

```c++
template<typename T, typename = void>
void is32bit(){
    std::cout << "YES." << std::endl;
}
```

如果觉得这样做的可读性仍然不高，我们还可以借助别名模板对其进一步简化：

```c++
template<typename T>
using Is32Bit_t = typename std::enable_if<sizeof(T) == 4>::type;

template<typename T, typename=Is32Bit_t<T>>
void is32bit(){
    std::cout << "YES." << std::endl;
}
```



## SFINAE

SFINAE发生在类型替换期间，当编译器在尝试实例化一个模板时，会将作为占位符的模板参数替换成具体类型，在替换过程中如果出现语法正确但语义错误的情况，则会忽略该模板，继续尝试实例化其他候选的模板，只有在所有候选模板都尝试完并且没有任何一个模板能够替换成功时，才会报告错误。为了更清晰地体会SFINAE特性，我们先定义如下模板：

```c++
struct A{ using type=int; };
struct B{};

template<typename T, typename=typename T::type>
void checkType(){
	std::cout << "Type A." << std::endl;
}
```

本例中我们定义了函数模板`checkType`，注意模板代码中的`typename=typename T::type`，当我们以类型A调用函数模板时，它将正常工作：

```c++
checkType<A>();
```

T被替换为A时，由于A内部定义了类型成员type，因此`typename=typename A::type`在语法和语义上都正确，替换成功。如果我们以类型B来调用函数模板：

```c++
checkType<B>();
```

由于类型B并没有定义类型成员type，所以`typename=typename B::type`虽然在语法上正确，但是语义却是错误的，导致替换失败，编译器将忽略checkType。在这之后，由于没有其他可以用于类型C实例化的checkType函数模板，编译器将会报告错误。

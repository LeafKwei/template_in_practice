# 《处理字符串字面量和原始数组》

## 字符串字面量和数组的退化

很早之前，我们看到过使用字符串字面量[1]和原始数组时，模板参数展现出的不同效果：

* 传值调用：会导致参数退化为指向数组元素的指针
* 传引用调用：任何形式的传引用调用都不会导致参数退化，因此参数将仍然保持为指向数组的引用

两者各有优劣。当数组退化为指针时，我们就无法区分对指针的处理和对数组的处理。另一方面，当一个位置可能处理字符串字面量时，不退化反而可能导致问题，因为不同长度的字符串字面量被视为不同的类型，例如：

```c++
template<typename T>
void compare(T &arg1, T &arg2){
	/* whatever */
}

compare("Hello", "World!"); //错误，arg1和arg2是不同的类型
```

在这个例子中，函数模板compare的参数arg1和arg2使用的是同一个模板参数T，这就意味着编译器根据参数arg1和arg2推断出来的T的类型类型必须是一致的。然而实际情况却是，arg1是对字符串字面量`"Hello"`的引用，arg2是对字符串字面量`World!`的引用，由于引用不会发生退化，因此由arg1推断的T类型为`const char[6]`，由arg2推断的T类型为`const char[7]`，由于两者类型不一致，因此在模板推断/替换阶段，该模板就会被排除，而由于没有其他普通函数/函数模板可用，因此编译器就会停止编译并提示错误。

解决这个问题可用通过声明使用传值调用的函数模板来解决，例如：

```c++
template<typename T>
void compare(T arg1, T arg2){
	/* whatever */
}

compare("Hello", "World!"); //OK
```

此时，字符串字面量的类型就会在调用时从`const char[6]`和`const char[7]`退化为`const char*`，因此从arg1和arg2中推断出的T类型同为`const char*`。



## 专门用于字符串字面量和数组的实现

有时我们的实现可能必须区分传入的参数是一个指针还是一个数组，当然，前提条件是这个参数在这之前还没有发生退化。要区分这些情况，我们有两个选择：

* 我们可用声明仅对数组有效的模板参数

```c++
template<typename T, std::size_t L1, std::size_t L2>
void foo(T (&arg1)[L1], T (&arg2)[L2]){
    /* 退化arg1和arg2 */
    T *p1 = arg1;
    T *p2 = arg2;
    
    /* 按指针的形式使用arg1和arg2 */
}
```

参数arg1和arg2以数组形式声明，因此对数组形式的参数会匹配的更好。传递给arg1和arg2的数组必须具有相同的元素类型T。为了支持不同长度的数组，我们声明了两个非类型模板参数L1、L2，用于获取编译器推断出的两个数组的长度。

* 也可用通过类型萃取来检查传入的参数是否是一个数组

```c++
template<typename T, 
	typename = std::enable_if_t<std::is_array_v<T>>>
void foo(T &&arg1, T &&arg2){
	/* whatever */
}
```

(注：在笔者测试时，发现这个模板并不能在参数是数组时正常工作，不知道是笔者的测试用例有问题还是作者的例子有问题)



## 处理返回值

对于返回值，我们也可以决定是按值返回还是按引用返回，然而，返回一个引用可能会成为潜在问题的源头，因为我们正在引用一个超出我们控制范围的某个对象。以下是几个返回引用的场景：

* 返回容器内的元素(例如std::vector)
* 返回允许外界访问的类成员
* 返回用于链式调用的对象(例如重定向运算符<<)

补充一点，如果我们仅希望返回的类成员对外界是只读的，那么应该按const引用的形式返回。

注意，如果使用不当，那么上面的所有情况都可能导致问题，例如：

```c++
std::string *str = new std::string("Hello");
auto &s0 = (*str)[0];
delete str;
std::cout << s0; //错误
```

在本例中，我们获取了str的一个元素的引用，并且在删除了string对象之后，还尝试通过该引用来访问其中的元素，由于此时的string对象已经不存在了(换句话说，s0现在是个悬垂引用)，因此访问操作将引发未定义行为。

老道的程序员可能很容易避免上述问题，但是，有时问题可能会变得不那么明显，例如：

```c++
auto str = std::make_shared<std::string>("Hello");
auto &s0 = (*str)[0];
str.reset();
std::cout << s0;
```

在这个例子中，对str的删除操作从之前显式的delete变成了调用智能指针的reset函数，这会减少智能指针内部对string对象的引用计数，而当智能指针中对string对象的引用计数归零后，对应的string对象将被删除，此时再引用s0也同样会引发未定义行为。

我们应该确保函数模板是按值返回结果的。但是，即使在返回值类型的位置直接使用模板参数Ｔ，在某些情况下Ｔ也可能会被隐式地推断为一个引用，例如：

```c++
template<typename T>
T foo(T &&arg){
    return T{};
}
```

arg是一个转发引用，当我们传递一个左值时，T会被推断为为左值类型的引用。即使我们以按值调用的方式来声明函数参数，T也仍然可能会因为显式指定模板参数而变成引用：

```c++
template<typename T>
T foo(T arg){
    return T{};
}

foo<int&>(100); //显式指定模板参数为int&
```

为了保证安全，我们有两个选择：

* 使用类型萃取`std::remove_reference`将T转换为一个非引用类型

```c++
template<typename T>
typename std::remove_reference<T>::type foo(T arg){
    return T{};
}
```

* 将返回类型声明为`auto`，交给编译器推断，由于`auto`总是退化的，因此可以解决T被推断为引用的问题

```c++
template<typename T>
auto foo(T arg){
	return T{};
}
```



## 注：

1. 字符串字面量是指形如`"Hello"`的这类直接给出字符串内容的字面量，它们本质上是一个const字符数组，例如`const char[6]`
# 《偏特化》

**【偏特化的概念】**

类模板可以不必针对一个完整的具体类型进行特例化，相反，类模板可以仅针对类型的一部分属性和特征(例如指针、引用)进行特例化，我们将这种部分特例化的形式称为偏特化。考虑如下例子：

```c++
/* 通用模板 */
template<typename T>
struct Poster{
    void post(T load){
        std::cout << "General: " << load << std::endl;
    }
};

/* 针对指针的偏特化 */
template<typename T>
struct Poster<T*>{
    void post(T *load){
        std::cout << "For pointer: " << *load << std::endl;
    }
};

/* 针对引用的偏特化 */
template<typename T>
struct Poster<T&>{
    void post(T &load){
        std::cout << "For reference: " <<load << std::endl;
    }
};
```

在这个例子中，特例`struct Poster<T*>`和`struct Poster<T&>`就是我们针对指针和引用类型的偏特化，当用户在实例化Poster时，如果给定的类型是一个指针或者引用，那么编译器将会优先采用我们的偏特化版本。例如：

```c++
Poster<int*> poster1;   //优先采用指针版本
Poster<int&> poster2;  //优先采用引用版本
```

偏特化的能力不止于此，在多模板参数的环境下，我们可以仅对其中的一部分进行特例化，或者根据它们之间的关系和特征进行特例化，例如：

```c++
template<typename T, typename U>
struct TypeChecker{
	int value(){
		return -1;
	}
};

/* 如果T和U是同一类型 */
template<typename T>
struct TypeChecker<T,T>{
	int value(){
		return 0;
	}
};

/* 如果T是指针而U是引用 */
template<typename T, typename U>
struct TypeChecker<T*,U&>{
	int value(){
		return 1;
	}
};

/* 如果T是char */
template<typename U>
struct TypeChecker<char,U>{
	int value(){
		return 2;
	}
};
```

在这个例子中，我们对TypeChecker进行了不同情况下的偏特化，并可以根据返回结果来确定模板参数T和U之间的关系或是特征。下方是使用不同类型作为模板参数时得到的结果：

```c++
TypeChecker<int, int> ck1;
TypeChecker<int*, double&> ck2;
TypeChecker<char, double> ck3;

std::cout << ck1.value() << std::endl; //0
std::cout << ck2.value() << std::endl; //1
std::cout << ck3.value() << std::endl; //2
```

在特例化时我们还可以对类模板的内容进行细微的调整，例如更改函数的返回值类型：

```c++
template<typename T>
struct TypeChecker<T,T>{
	bool value()            //将函数返回值类型从int改为bool
		return true;
	}
};
```

**【特例化与模板参数声明】**

将偏特化与全特化相比，我们可以发现全特化时的模板参数声明是空的，即`template<>`，而偏特化则或多或少会保留一定数量的模板参数，例如对于类模板TypeChecker而言：

```c++
template<typename T, typename U>
struct TypeChecker{}

/* 全特化 */
template<>
struct TypeChecker<int, int>{}

/* 偏特化 */
template<typename U>
struct TypeChecker<int, U>{}
```

全特化版本的TypeChecker没有声明任何模板参数，而偏特化版本的TypeChecker声明了模板参数U。在全特化时，由于两个模板参数T、U的类型已经完全确定(本例中为int)，因此已经没有模板参数存在的必要，所以全特化时的模板参数声明是留空的；而在偏特化时，由于我们只给出了一部分类型或者特征，所以模板中还存在着一部分类型是不确定的，所以才需要声明相应的模板参数。
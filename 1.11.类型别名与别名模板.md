# 《类型别名与别名模板》

关键字`typedef`和`using`(C++11引入)可以为一个已有的类型定义它的别名，这样做的好处有：

* 简化类型声明，例如将`std::map<std::string, std::vector<int>>`简化为VectorStringMap
* 为类型赋予新的含义，例如为`unsigned long long`定义别名UID，使用UID更能直观体现出该类型的作用
* 定义别名模板，通过使用using，我们可以定义别名模板，例如标准库中的std::enable_if_t



**【类型别名与类型声明】**

类型别名(Typedefs)是指使用typedef为类型定义的别名，为了与之区分，使用using为类型定义的别名被称为别名声明(Alias declareations)。类型别名和别名声明在一般情况下没有区别，它们都能实现相同的功能：

```c++
//在实际情况下，为了避免名称冲突，只能使用其中一个
typedef unsigned long long UID;
using UID = unsigned long long;
```

这两条语句都是为`unsigned long long`定义了一个别名`UID`。类型和该类型的别名是等价的，我们可以在使用`unsigned long long`的地方使用`UID`，也可以在使用`UID`的地方使用`unsigned long long`。例如：

```c++
void needUID(UID uid){ /* whatever */ }

UID uid1 = 2020939493UL;
unsigned long long uid2 = 2020939494UL
needUID(uid1); //OK
needUID(uid2); //OK
```



**【别名模板】**

using与typedef最大的不同就是使用using定义的别名可以模板化，这使得我们在为模板定义别名时，可以不用立刻确定所有的模板参数，相反，我们可以在为模板定义别名的同时，将模板参数也一并声明，并在后续由别名的使用者提供具体的类型，例如：

```c++
template<typename T>
using AnyStringMap = std::map<std::string, std::vector<T>>;

AnyStringMap<int> istrmap;      //等同于std::map<std::string, std::vector<int>>
AnyStringMap<double> dstrmap;   //等同于std::map<std::string, std::vector<double>>
```

在这个例子中，我们在定义别名`AnyStringMap`时，声明了模板参数T，并将其作为了`std::vector`的模板参数，因此`AnyStringMap`的使用者就可以根据自己的需要，通过提供不同类型作为模板参数来决定`std::vector`的元素类型。
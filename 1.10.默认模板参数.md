# 《默认模板参数》

类模板的模板参数也可以具有默认类型，当我们实例化模板时，如果没有在相应的位置指定具体类型，那么该模板参数将使用默认类型。下方的例子为模板参数U指定了一个默认类型double：

```c++
template<typename T, typename U=double>
struct TypeChecker{}
```

当我们实例化TypeChecker时，如果没有指定U的类型，那么U将默认采用double：

```c++
TypeChecker<int> ck; //T为int，U为double
```

当为一个模板参数指定默认类型时，必须确保它右侧的所有模板参数都具有默认类型，这是由于在实例化模板时，编译器会将我们给定的一系列具体类型按照模板参数的声明顺序依次绑定到模板参数上，例如：

```c++
template<typename T, typename U, typename V>
struct Foo{}
```

当我们实例化Foo时：

```c++
Foo<int, double, char> foo;
```

编译器会按照模板参数声明的顺序将我们给定的具体类型int、double、char依次绑定到模板参数T、U、V上面，试想一下，如果此时我们为U指定一个默认类型，即：

```c++
template<typename T, typename U=double, typename V>
struct Foo{}
```

那么，对于如下实例：

```c++
Foo<int, char> foo;
```

我们的预期是将int绑定到T，char绑定到V上，但事实并非如此，由于在模板实例化时，拥有默认类型的模板参数同样可以被指定类型，因此上面的例子中int被绑定到了T，char被绑定到了U，而V则没有指定任何类型，最终在编译时产生错误。因此，对于一个模板参数而言，除非它右侧的模板参数都具有默认类型，否则就不应该为它指定默认类型。
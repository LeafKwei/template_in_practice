# 《类模板的名称和作用域》

当位于类模板或其作用域声明的内部时，类模板的名称可以替代类模板的全称。我们以类模板Bar为例：

```c++
template<typename T>
class Bar{
	Bar(){ std::cout << "Constructor." << std::endl; }  //构造、析构函数的名称与类名绑定
	~Bar(){ std::cout <<"Deconstructor." << std::endl; } 
	
	Bar(const Bar &oth){  //在模板内部，模板名称可以代替模板全称，即Bar可以代替Bar<T>
        std::cout << "Copy constructor." << std::endl;
    }
    
    void print(const T &v);
    bool operator==(const Bar &oth);
}
```

在类模板内部时，类模板的名称`Bar`可以代替类模板的全称`Bar<T>`，因此`const Bar &oth`等同于`const Bar<T> &oth`。构造、析构函数比较特殊，它们的名称和类的名称绑定，所以只能使用类模板的名称而非全称。

当类模板Bar的成员需要在类模板外定义时，需要先使用与Bar一致的模板声明`template<typename T>`将该成员标识为一个模板，随后通过在该成员的名称前添加作用域声明`Bar<T>::`将该成员限定为`Bar<T>`的成员，此后，出现在`Bar<T>::`之后的内容就可视为在类模板的内部，可以使用类模板的名称Bar来代替全称`Bar<T>`。

```c++
template<typename T>
void Bar<T>::print(const T &v)          { /* do something */ }

template <typename T>
bool Bar<T>::operator==(const Bar &oth) { /* do something */  }  //const Bar &oth等同于const Bar<T> &oth
```


# 《使用类模板的部分内容》

函数模板仅在被使用时才实例化，类似的，类模板的成员函数也是在被使用时才实例化，这个做法既是节省时间和空间的做法，同时也让我们可以仅使用类模板的部分内容。例如，对于下方的类模板：

```c++
template<typename T>
class Operation{
public:
	bool isEqual(const T &a, const T &b){
		return a == b;
	}
	
	bool isLargeThan(const T &a, const T &b){
		return a > b;
	}
};
```

我们定义如下两个类型：

```
struct TypeA{
	int v;
	bool operator==(const TypeA &oth) const { return this -> v == oth.v; }
};

struct TypeB{
	int v;
	bool operator==(const TypeB &oth) const { return this -> v == oth.v; }
	bool operator>(const TypeB &oth) const { return this -> v > oth.v; }
};
```

然后，我们编写源文件main1.cpp：

```c++
int main(void){
	Operation<TypeA> op;
	op.isEqual(TypeA{100}, TypeA{200});
}
```

当我们编译并执行这段程序时可以发现，即使TypeA没有定义`>`操作，编译依然可以通过，程序的执行也没有问题，其中的原因就是我们只在这段程序中使用了`isEqual`函数，因此编译器也只实例化了该函数，而对于`isLargeThan`函数则不进行实例化，所以这段程序实际也只使用到了TypeA类型的`==`操作，因此得以正常编译和执行。从这个例子中我们可以看出模板的另一个规则：被用作类模板或函数模板的模板参数的类型，可以仅提供**必须**的而不是所有**可能**需要的操作。对于本例而言，实际使用到的`==`操作就是TypeA必须提供的，而未被使用但是类模板中存在的`>`操作就是可能需要的。

现在让我们来编写第二个main2.cpp文件：

```c++
int main(void){
	Operation<TypeA> op;
	op.isEqual(TypeA{100}, TypeA{200});
	op.isLargeThan(TypeA{100}, TypeA{200});
}
```

可以看到，这段程序中我们调用了`isLargeThan`函数，但是TypeA并未定义`>`操作，因此这段程序最终会引发编译错误。相反，如果我们使用的是TypeB，那么一切都将恢复正常：

```c++
int main(void){
	Operation<TypeB> op;
	op.isEqual(TypeB{100}, TypeB{200});
	op.isLargeThan(TypeB{100}, TypeB{200});
}
```


# 《类模板特例化》

**【特例化整个类模板】**

我们可以为某个类型特例化类模板，所谓特例化，是指由用户定义的，针对特定类型的一套模板代码的实例，当我们使用该类型尝试实例化模板时，编译器将会采用已有的特例化版本的模板代码。特例化的目的是处理那些无法通过通用模板代码完成的任务。让我们先定义一个如下的模板：

```c++
template<typename T>
class Poster{
public:
	void post(const T &load){
        std::cout << load << std::endl;
    }
};
```

该模板中提供了post函数，用于将指定的内容load输出到标准输出中，该函数对于std::cout所支持的类型都能工作地很好，但是一旦遇到用户定义的类型，例如：

```c++
struct MyLoad{
	int id;
	std::string str;
};
```

此时post函数就无法正常工作了，因为std::cout并不支持MyLoad类型。为了解决这个问题，我们就需要对Poster进行特例化，也就是专门编写一套用于处理MyLoad这个特例类型的模板代码。特例化模板以`template<>`开头，类名之后要指定此模板针对的特例类型，例如`<MyLoad>`，如果模板参数有多个，那么特例类型也要指定多个，与模板参数相互对应。在这之后就可以开始编写特例化的模板代码，其中的模板参数要替换成特例类型：

```c++
template<>
class Poster<MyLoad>{
public:
	void post(const MyLoad &load){
		std::stringstream buf;
		buf << "id: " << load.id << ", str: " << load.str;
        std::cout << buf.str() << std::endl;
    }
};
```

可以看到，在特例化Poster中，模板参数T都被替换为了特例类型MyLoad。本例中，这种所有模板参数都被完全确定为特例类型的特例化形式，我们称为完全特例化(全特化)，与之相对的还有仅确定部分模板参数或属性(例如指针、引用)的部分特例化(偏特化)。

**【特例化与实例化的顺序】**

如果想要对一个类型X特例化某个模板，那么特例化必须在模板实例化之前进行，原因是当模板实例化后，编译器已经为模板生成了用于类型X的实例，此时若再出现特例化版本，两者就会产生冲突，编译器将报告错误。

```c++
template<typename T>
struct Bar{
    void tell(){ std::cout << "General." << std::endl; }
};

Bar<int> bar;

//在实例化之后才进行特例化，两个版本将产生冲突
template<>
struct Bar<X>{
    void tell(){ std::cout << "Special." << std::endl; }
};
```

**【特例化单个成员函数】**

除了特例化整个类模板外，我们还可以只特例化类模板中的单个成员函数。特例化成员函数需要在类模板外部进行，此时我们需要像往常一样指定成员函数所属的类，例如`Bar<int>::tell`，而在这个过程中，我们实例化了类模板，因此在特例化成员函数之后，就无法再对同一类型特例化类模板。

```c++
template<typename T>
struct Bar{
    void tell(){ std::cout << "General." << std::endl; }
};

template<>
void Bar<int>::tell(){  //注意，特例化成员函数时也实例化了Bar
	std::cout << "Special." << std::endl;
}
```


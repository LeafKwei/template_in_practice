# 《警惕返回临时变量的引用导致的运行时错误》

首先编写如下代码：

```c++
/* 模板1，引用传递 */
template<typename T>
const T& max(const T &a, const T &b){
    std::cout << "Calling max(const T&, const T&)" << std::endl;
    return b < a ? a : b;
}

/* 普通函数，值传递 */
const char* max(const char *a, const char *b){
    std::cout << "Calling max(const char*, const char*)" << std::endl;
    return std::strcmp(b, a) < 0 ? a : b;
}

/* 模板2，引用传递 */
template <typename T>
const T& max(const T&a, const T &b, const T &c){
    std::cout << "Calling max(const T&, const T&, const T&)" << std::endl;
    std::cout << typeid(T).name() << std::endl;  //PKc means Pointer(P) to const(K) char(c)
    return max(max(a, b), c);
}
```

对于下方的调用：

```c++
const char *a = "abc";  //此处声明变量a、b、c只是为了方便后续描述，实际上max("abc", "def", "ghi")也是同样的结果
const char *b = "def";
const char *c = "ghi";
std::cout << max(a, b, c) << std::endl;
```

这段程序在运行时将会引发异常，其原因是模板`max(const T&a, const T &b, const T &c)`返回了一个临时变量的引用，进而导致了`std::cout`引用到了一个不存在的变量，从而产生异常。具体细节我们分析如下：`max(a, b, c)`首先与模板`max(const T&a, const T &b, const T &c)`匹配，然后，在该模板内部，对于调用`max(a, b)`，由于普通函数`max(const char *a, const char *b)`要比模板`max(const T &a, const T &b)`更加特例化，所以编译器会在此处选择普通函数版本的max，同理，对于`max(max(a, b), c)`，编译器同样会选择普通函数版本的max，然后模板`max(const T&a, const T &b, const T &c)`返回的是一个引用，在本例中，该引用绑定的是表达式`max(max(a, b), c)`返回的变量，引发问题的关键在于`max(max(a, b), c)`返回的是一个临时(局部)变量，当`return max(max(a, b), c)`执行完毕后，该变量便被回收了，这就使得模板`max(const T&a, const T &b, const T &c)`返回的引用成为了一个悬垂引用，进而导致了异常的发生。

再来看另一个例子：

```c++
std::cout << max(1, 2, 3) << std::endl;
```

这段程序可以正常运行，原因在于对于int类型，`max(max(a, b), c)`将匹配模板`const T& max(const T &a, const T &b)`，而该模板无论是返回值还是参数都是引用形式，这些引用都绑定到了最开始的`max(1, 2, 3)`的参数1、2、3上，因此在该语句执行完毕前，这些参数都会一直存在，所以就不会发生上一个例子中的悬垂引用问题。

# 《传值》

**【传值与传引用】**

从一开始，C++就提供了传值调用(call-by-value)和传引用调用(call-by-reference)两种调用方式。有时并不是很容易选择该使用哪一种方式：对于那些不平凡的对象(nontrivial objects)，经常使用传引用调用可以得到更低的开销，但会让事情更复杂。在C++11引入了移动语义后，我们有了不同的方式来传递引用：

* const X&：常量左值引用。参数指向被传递的对象，不具备修改该对象的能力
* X&：非常量左值引用。参数指向被传递的对象，具备修改该对象的能力
* X&&：右值引用。参数指向被传递的对象，具备修改该对象或者“窃取”该对象资源的能力

在前面的内容中我们推荐在函数模板中通过传值的方式来传递参数，除非遇到以下情况：

* 拷贝不可用
* 传递的参数将被用于携带返回值
* 该函数模板需要将参数及其属性原样转发到其他地方
* 使用引用有显著的性能提升



**【传值】**

在我们按值传递参数(arguments)时，每个参数原则上都会被拷贝，因此函数接收到的参数(parameters)都将是我们传递的参数的拷贝。对于类而言，创建的拷贝(副本)一般会通过拷贝构造函数进行初始化。调用一个拷贝构造函数可能会产生较大的开销，但我们也有各种办法来避免这些开销，实际上：编译器可能会优化拷贝操作，并可能对一些复杂的对象执行移动语义。例如，我们提供如下的函数模板：

```c++
template <typename T>
void print(T arg){
	/* whatever */
}
```

然后，我们传递一个string对象作为参数：

```c++
std::string str("Hello");
print(str);
```

再次提醒，我们正在按值传递参数，因此print函数的参数arg是一个源自str的副本，这个副本通过string类的拷贝构造函数创建，而这是一种隐式的高开销操作，因为原则上该副本将会执行一种被称为“完全拷贝(full-copy)”或“深拷贝(deep-copy)”的操作，此举会在其内部分配属于其自身的内存以容纳str中的数据。

然而，这种隐式地调用拷贝构造函数的拷贝操作并不一定总是会发生，对于以下例子：

```c++
std::string getString();
std::string str("Hello");

print(str);
print(std::string("Hello"));
print(getString());
print(std::move(str));
```

在`print(str)`中，我们传递了一个左值(lvalue)，这意味着拷贝构造函数将被使用。而在`print(std::string("Hello"))`以及`print(getString())`中，当直接对纯右值(prvalue，指那些在表达式中临时创建的对象或者由函数返回的对象)调用函数时，编译器通常会优化参数传递过程，因此不会发生拷贝构造函数的调用(从C++17开始这种优化是必须的)。在最后的`print(std::move(str))`中，我们传递了一个将亡值(xvalue，使用std::move转换的非常量左值对象)，通过std::move来显式地强调我们将不再使用str中的值，以此强制调用移动构造函数。

从上面的例子中可以看出，对于按值传递的调用而言，高开销的情况只在我们传递一个左值(lvalue，一个此前创建的并且在之后还会继续使用的对象)的参数时发生。毫无疑问，这是一个相当普遍的情况，例如我们经常会提前创建一个对象，并在稍候将其传递给其他函数。



**【传值时的退化】**

在按值传递时，我们还需要关注另一件事情——退化，对于原始数组(raw arrays)，退化会使原始数组转换为指针；对于其他种类的对象，退化会使得其中的限定符(例如const)被移除(就像是把对象用来初始化另一个使用auto声明的对象一样)。

```c++
int arr[3];
const std::string str = "Hello";
print(str);         //const std::string退化为std::string，print的模板参数T被推断为std::string
print("Hello");     //const char[6]退化为const char*，T被推断为const char*
print(arr);         //int[3]退化为int*，T被推断为int*
```

我们以`print("Hello")`为例，当我们传递`"Hello"`时，其类型会从`const char[6]`退化为`const char*`，这也是模板参数T被推断出的类型。因此，print模板最终会被实例化为：

```c++
void print(const char *arg){
	/* whatever */c
}
```
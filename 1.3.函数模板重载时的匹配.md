# 《函数模板重载时的匹配》

函数模板在调用时可以仅指定一部分模板参数的类型(按从左到右的顺序)，剩下的模板参数由编译器从函数参数中推导。例如对于下方的模板：

```c++
template<typename RT, typename T1, typename T2>
RT max(T1 a, T2 b){
	return a + b;
}
```

我们可以使用`<int>`来仅指出模板参数RT的类型，而将剩余的T1和T2交给编译器从函数参数中推断(前提是函数参数中存在着足够推断出T1和T2的信息)：

```c++
max<int>(10, 20);
```

可以看到，我们在模板中声明了`(T1 a, T2 b)`，因此编译器很容易地从函数参数`(10, 20)`中推断出T1和T2都是int。

任何时刻我们都应该保证只有一个函数模板匹配当前的调用，如果一个调用存在多个匹配的函数模板，那么就会引发**模糊**错误。以下方的代码为例：

```c++
template<typename T1, typename T2>
auto max(T1 a, T2 b){
    //如果返回值使用auto替代，并且没有在函数尾部使用“->”显式指定返回值类型，那么编译器将从return语句推断返回值类型
    return a < b ? b : a;  
}

template<typename RT, typename T1, typename T2>
RT max(T1 a, T2 b){
    return a < b ? b : a;
}
```

对于下方的语句：

```c++
max<int>(10, 20);
```

编译器将提示<u>有多个模板匹配该调用</u>并停止编译，这是因为我们指定的类型`<int>`无论是对于第一个模板的T1还是第二个模板的RT来说都是可以接受的，而剩余的模板参数都可以从函数参数中推断得到，这就使得在编译器看来有多个匹配的模板，并且这些模板匹配的都一样好，所以引发了模糊错误。

还是以上面的两个模板为例，我们来看下方的这个调用：

```c++
max<long double>(10.2, 6);
```

这个调用就不会出现模糊错误，虽然`long double`同样既可以是T1，也可能是RT，但是如果将其作为T1，那么由于函数参数10.2是double类型的，到long double需要经过一次隐式类型转换，为了避免这种性能开销，编译器会优先选择`RT max(T1 a, T2 b)`，因为它的模板参数T1可以直接推断为double，无需经过隐式类型转换。

由于函数模板可以重载，并且之前所述，我们可以仅为调用指定部分模板参数的类型，而这可能导致多个重载的模板都匹配该调用，从而引发模糊错误：

```c++
max<int>(10, 20);
```

对于指定的类型`<int>`，由于函数的首个参数是int类型，所以无论是T1还是RT被指定为int，两个模板都没有额外的性能开销，因此编译器认为这两个模板匹配的一样好，因此就会产生模板错误。